<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TMH Device Inventory Report</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://alcdn.msauth.net/browser/2.30.0/js/msal-browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Professional color palette */
            --primary-blue: #1e3a5f;
            --secondary-blue: #2c5282;
            --accent-blue: #3182ce;
            --light-blue: #e6f2ff;
            --success-green: #059669;
            --warning-amber: #f59e0b;
            --danger-red: #dc2626;
            --neutral-50: #fafafa;
            --neutral-100: #f4f4f5;
            --neutral-200: #e4e4e7;
            --neutral-300: #d4d4d8;
            --neutral-400: #a1a1aa;
            --neutral-500: #71717a;
            --neutral-600: #52525b;
            --neutral-700: #3f3f46;
            --neutral-800: #27272a;
            --neutral-900: #18181b;
            
            /* Spacing system */
            --space-xs: 0.25rem;
            --space-sm: 0.5rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            --space-2xl: 3rem;
            
            /* Typography */
            --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            --text-3xl: 1.875rem;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            
            /* Border radius */
            --radius-sm: 0.25rem;
            --radius-md: 0.375rem;
            --radius-lg: 0.5rem;
            --radius-xl: 0.75rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            font-size: var(--text-base);
            line-height: 1.5;
            color: var(--neutral-900);
            background-color: var(--neutral-50);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Modern header design */
        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
            color: white;
            padding: var(--space-lg) 0;
            position: relative;
            box-shadow: var(--shadow-md);
        }

        .header-content {
            max-width: 1280px;
            margin: 0 auto;
            padding: 0 var(--space-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left h1 {
            font-size: var(--text-2xl);
            font-weight: 600;
            margin-bottom: var(--space-xs);
            letter-spacing: -0.025em;
        }

        .header-left p {
            font-size: var(--text-sm);
            opacity: 0.9;
            font-weight: 400;
        }

        .urgent-indicator {
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-xl);
            font-size: var(--text-sm);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .urgent-indicator:hover {
            background: rgba(239, 68, 68, 1);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .urgent-indicator.no-urgent {
            background: rgba(5, 150, 105, 0.9);
        }

        .urgent-indicator.no-urgent:hover {
            background: rgba(5, 150, 105, 1);
        }

        .urgent-count {
            font-size: var(--text-lg);
            font-weight: 700;
        }

        /* Container and layout */
        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: var(--space-xl) var(--space-lg);
        }

        /* Modern card design */
        .card {
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--neutral-200);
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-md);
        }

        .card-header {
            padding: var(--space-lg);
            border-bottom: 1px solid var(--neutral-200);
            background-color: var(--neutral-50);
        }

        .card-header h2 {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--neutral-900);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .card-body {
            padding: var(--space-lg);
        }

        /* Upload section redesign */
        .upload-section {
            margin-bottom: var(--space-xl);
        }

        .upload-area {
            border: 2px dashed var(--neutral-300);
            border-radius: var(--radius-lg);
            padding: var(--space-2xl);
            text-align: center;
            background-color: var(--neutral-50);
            transition: all 0.2s ease;
        }

        .upload-area:hover {
            border-color: var(--accent-blue);
            background-color: var(--light-blue);
        }

        .file-label {
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-md) var(--space-xl);
            background-color: var(--primary-blue);
            color: white;
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: var(--text-base);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .file-label:hover {
            background-color: var(--secondary-blue);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .file-label svg {
            width: 20px;
            height: 20px;
        }

        /* Enhanced metric cards */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-xl);
        }

        .metric-card {
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--neutral-200);
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-blue);
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .metric-card.ios::before {
            background: var(--accent-blue);
        }

        .metric-card.android::before {
            background: var(--success-green);
        }

        .metric-card.total::before {
            background: var(--primary-blue);
        }

        .metric-icon {
            width: 48px;
            height: 48px;
            background: var(--light-blue);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: var(--space-md);
        }

        .metric-card.android .metric-icon {
            background: rgba(5, 150, 105, 0.1);
        }

        .metric-label {
            font-size: var(--text-sm);
            color: var(--neutral-600);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--space-xs);
        }

        .metric-value {
            font-size: var(--text-3xl);
            font-weight: 700;
            color: var(--neutral-900);
            line-height: 1.2;
            margin-bottom: var(--space-sm);
        }

        .metric-description {
            font-size: var(--text-sm);
            color: var(--neutral-500);
            line-height: 1.4;
        }

        .metric-trend {
            position: absolute;
            top: var(--space-md);
            right: var(--space-md);
            font-size: var(--text-sm);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .trend-up {
            color: var(--success-green);
        }

        .trend-down {
            color: var(--danger-red);
        }

        /* Compliance section redesign */
        .compliance-section {
            margin-bottom: var(--space-xl);
        }

        .compliance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-lg);
        }

        .compliance-card {
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--neutral-200);
        }

        .compliance-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .compliance-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--neutral-900);
        }

        .compliance-percentage {
            font-size: var(--text-2xl);
            font-weight: 700;
            color: var(--success-green);
        }

        .compliance-bar-container {
            background-color: var(--neutral-100);
            height: 12px;
            border-radius: var(--radius-xl);
            overflow: hidden;
            position: relative;
        }

        .compliance-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-green), #10b981);
            transition: width 0.6s ease;
            border-radius: var(--radius-xl);
        }

        .compliance-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-sm);
            margin-top: var(--space-md);
            padding-top: var(--space-md);
            border-top: 1px solid var(--neutral-200);
        }

        .compliance-stat {
            text-align: center;
        }

        .compliance-stat-value {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--neutral-900);
        }

        .compliance-stat-label {
            font-size: var(--text-xs);
            color: var(--neutral-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Modern table design */
        .data-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: var(--text-sm);
        }

        .data-table th {
            background-color: var(--neutral-50);
            padding: var(--space-md);
            text-align: left;
            font-weight: 600;
            color: var(--neutral-700);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: var(--text-xs);
            border-bottom: 2px solid var(--neutral-200);
        }

        .data-table td {
            padding: var(--space-md);
            border-bottom: 1px solid var(--neutral-100);
            color: var(--neutral-700);
        }

        .data-table tr:hover td {
            background-color: var(--neutral-50);
        }

        /* Status badges */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-xl);
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-supported {
            background-color: rgba(5, 150, 105, 0.1);
            color: var(--success-green);
        }

        .status-security {
            background-color: rgba(245, 158, 11, 0.1);
            color: var(--warning-amber);
        }

        .status-ended {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger-red);
        }

        /* Action buttons redesign */
        .actions-bar {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-xl);
            padding: var(--space-lg);
            background-color: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--neutral-200);
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm) var(--space-lg);
            border: none;
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
        }

        .btn-primary {
            background-color: var(--primary-blue);
            color: white;
            box-shadow: var(--shadow-sm);
        }

        .btn-primary:hover {
            background-color: var(--secondary-blue);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background-color: white;
            color: var(--neutral-700);
            border: 1px solid var(--neutral-300);
        }

        .btn-secondary:hover {
            background-color: var(--neutral-50);
            border-color: var(--neutral-400);
        }

        /* Section layouts */
        .section {
            background: white;
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-xl);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--neutral-200);
        }

        .section-header {
            background: var(--neutral-50);
            padding: var(--space-md) var(--space-lg);
            border-bottom: 1px solid var(--neutral-200);
            font-weight: 600;
            color: var(--neutral-800);
            font-size: var(--text-base);
        }

        .section-body {
            padding: var(--space-lg);
        }

        /* Responsive grid layouts */
        .two-column {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-lg);
        }

        .three-column {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-lg);
        }

        /* Footer redesign */
        .footer {
            background-color: var(--primary-blue);
            color: white;
            text-align: center;
            padding: var(--space-xl);
            margin-top: var(--space-2xl);
            border-radius: var(--radius-lg);
        }

        .footer p {
            margin: var(--space-xs) 0;
            font-size: var(--text-sm);
        }

        /* Loading states */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--neutral-200);
            border-radius: 50%;
            border-top-color: var(--accent-blue);
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Status messages */
        .status-message {
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: var(--text-sm);
            margin-top: var(--space-md);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .status-success {
            background-color: rgba(5, 150, 105, 0.1);
            color: var(--success-green);
            border: 1px solid rgba(5, 150, 105, 0.2);
        }

        .status-error {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger-red);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .status-waiting {
            background-color: var(--neutral-100);
            color: var(--neutral-600);
            border: 1px solid var(--neutral-200);
        }

        .status-processing {
            background-color: rgba(245, 158, 11, 0.1);
            color: var(--warning-amber);
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: var(--space-md);
                text-align: center;
            }

            .metrics-grid {
                grid-template-columns: 1fr;
            }

            .compliance-grid {
                grid-template-columns: 1fr;
            }

            .actions-bar {
                justify-content: stretch;
            }

            .btn {
                flex: 1;
                justify-content: center;
            }
        }

        /* Print styles */
        @media print {
            * {
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            body {
                font-size: 10pt;
                line-height: 1.4;
            }

            .header {
                padding: var(--space-md) 0;
            }

            .container {
                padding: var(--space-md);
            }

            .actions-bar, .upload-section, .urgent-indicator {
                display: none !important;
            }

            .card, .section {
                box-shadow: none;
                border: 1px solid var(--neutral-300);
                break-inside: avoid;
            }

            @page {
                size: A4;
                margin: 0.5in;
            }
        }

        /* Existing styles continue below... */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-left">
                    <h1>Device Inventory Report</h1>
                    <p>Tallahassee Memorial Hospital - IT Asset Management</p>
                </div>
                <div id="urgentIndicator" class="urgent-indicator no-urgent" onclick="scrollToUrgentItems()" style="display: none;">
                    <span class="urgent-count">0</span>
                    <span>Urgent Items</span>
                </div>
            </div>
        </div>

        <div class="upload-section card">
            <div class="card-body">
                <div class="upload-area">
                    <input type="file" id="fileInput" accept=".xlsx,.xlsm,.csv" class="file-input" style="display: none;" />
                    <label for="fileInput" class="file-label">
                        <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20M12,12L8,16H10.5V19H13.5V16H16L12,12Z"/>
                        </svg>
                        Choose Excel or CSV File
                    </label>
                    <p style="margin-top: var(--space-sm); font-size: var(--text-sm); color: var(--neutral-500);">
                        Drop your file here or click to browse
                    </p>
                </div>
                <span id="fileName" class="file-name" style="display: block; margin-top: var(--space-md); color: var(--neutral-600); font-weight: 500;"></span>
                <div id="sheetSelectorContainer" style="display: none; margin-top: var(--space-lg); padding: var(--space-md); background-color: var(--neutral-50); border-radius: var(--radius-md); border: 1px solid var(--neutral-200);">
                    <label for="sheetSelect" style="font-weight: 600; color: var(--primary-blue); margin-right: var(--space-sm);">Select Sheet:</label>
                    <select id="sheetSelect" style="padding: var(--space-sm) var(--space-md); border: 2px solid var(--primary-blue); border-radius: var(--radius-sm); font-size: var(--text-sm); background-color: white; color: var(--primary-blue); font-weight: 500;"></select>
                    <small style="display: block; margin-top: var(--space-sm); color: var(--neutral-500); font-style: italic;">
                        Report will automatically regenerate when you select a different sheet
                    </small>
                </div>
                <div class="status-message status-waiting" id="statusMessage">Waiting for upload…</div>
            </div>
        </div>

        <div id="reportContainer">
            <div class="actions-bar">
                <button class="btn btn-primary" onclick="regenerateReport()">Regenerate Report</button>
                <button class="btn btn-primary" onclick="exportToPDF()">Export to PDF</button>
                <button class="btn btn-secondary" onclick="debugCategories()">Debug Categories</button>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card ios">
                    <div class="metric-icon">
                        <svg width="24" height="24" fill="#3182ce" viewBox="0 0 24 24">
                            <path d="M17.05 20.28C16.06 21.42 14.99 22 13.83 22C12.85 22 12.15 21.64 11.74 21.42C11.33 21.21 11.12 21.1 10.75 21.1C10.34 21.1 10.1 21.22 9.69 21.43C9.27 21.65 8.56 22 7.59 22C6.31 22 5.09 21.35 4 19.91C2.74 18.24 2 16.11 2 14.1C2 10.4 4.41 8.5 6.75 8.5C7.69 8.5 8.41 8.82 8.88 9.05C9.18 9.19 9.41 9.31 9.63 9.31C9.89 9.31 10.13 9.19 10.46 9.03C10.95 8.79 11.66 8.45 12.68 8.45C13.93 8.45 15.05 9 15.9 10C14.6 10.72 14 12.13 14 13.65C14 15.26 14.67 16.67 16.18 17.4C15.84 18.5 15.27 19.56 14.5 20.5L17.05 20.28M13.88 5.5C13.88 6.81 13.37 7.94 12.54 8.8C11.57 9.79 10.36 10.24 9.25 10.13C9.23 10 9.22 9.83 9.22 9.64C9.22 8.39 9.8 7.23 10.62 6.42C11.43 5.61 12.59 5.1 13.73 5C13.77 5.04 13.8 5.09 13.83 5.14C13.86 5.26 13.88 5.38 13.88 5.5Z"/>
                        </svg>
                    </div>
                    <div class="metric-label">Apple Devices</div>
                    <div class="metric-value" id="iosTotal">0</div>
                    <div class="metric-description">iPads, iPhones & iOS medical devices</div>
                    <div class="metric-trend trend-up" id="iosTrend" style="display: none;">
                        <span>↑</span>
                        <span id="iosTrendValue">0%</span>
                    </div>
                </div>
                <div class="metric-card android">
                    <div class="metric-icon">
                        <svg width="24" height="24" fill="#059669" viewBox="0 0 24 24">
                            <path d="M15.9,5C15.6,5 15.4,5.2 15.4,5.5V6.5C15.4,6.8 15.6,7 15.9,7C16.2,7 16.4,6.8 16.4,6.5V5.5C16.4,5.2 16.2,5 15.9,5M7.9,5C7.6,5 7.4,5.2 7.4,5.5V6.5C7.4,6.8 7.6,7 7.9,7C8.2,7 8.4,6.8 8.4,6.5V5.5C8.4,5.2 8.2,5 7.9,5M20,12.5C20,12.2 19.8,12 19.5,12H19V8C19,6.6 18.1,5.4 16.9,5.1L18.1,3.5C18.3,3.3 18.2,3 18,2.8C17.8,2.6 17.5,2.7 17.3,2.9L16,4.6C15.3,4.2 14.5,4 13.6,4H10.4C9.5,4 8.7,4.2 8,4.6L6.7,2.9C6.5,2.7 6.2,2.6 6,2.8C5.8,3 5.7,3.3 5.9,3.5L7.1,5.1C5.9,5.4 5,6.6 5,8V12H4.5C4.2,12 4,12.2 4,12.5V19.5C4,19.8 4.2,20 4.5,20H5C5.6,20 6,19.6 6,19V13H18V19C18,19.6 18.4,20 19,20H19.5C19.8,20 20,19.8 20,19.5V12.5M8,11C7.4,11 7,10.6 7,10C7,9.4 7.4,9 8,9C8.6,9 9,9.4 9,10C9,10.6 8.6,11 8,11M16,11C15.4,11 15,10.6 15,10C15,9.4 15.4,9 16,9C16.6,9 17,9.4 17,10C17,10.6 16.6,11 16,11Z"/>
                    </svg>
                    </div>
                    <div class="metric-label">Android Devices</div>
                    <div class="metric-value" id="androidTotal">0</div>
                    <div class="metric-description">Scanners, tablets & mobile android devices</div>
                    <div class="metric-trend trend-up" id="androidTrend" style="display: none;">
                        <span>↑</span>
                        <span id="androidTrendValue">0%</span>
                    </div>
                </div>
                <div class="metric-card total">
                    <div class="metric-icon">
                        <svg width="24" height="24" fill="#1e3a5f" viewBox="0 0 24 24">
                            <path d="M12,5.5A3.5,3.5 0 0,1 15.5,9A3.5,3.5 0 0,1 12,12.5A3.5,3.5 0 0,1 8.5,9A3.5,3.5 0 0,1 12,5.5M5,8C5.56,8 6.08,8.15 6.53,8.42C6.38,9.85 6.8,11.27 7.66,12.38C7.16,13.34 6.16,14 5,14A3,3 0 0,1 2,11A3,3 0 0,1 5,8M19,8A3,3 0 0,1 22,11A3,3 0 0,1 19,14C17.84,14 16.84,13.34 16.34,12.38C17.2,11.27 17.62,9.85 17.47,8.42C17.92,8.15 18.44,8 19,8M5.5,18.25C5.5,16.18 8.41,14.5 12,14.5C15.59,14.5 18.5,16.18 18.5,18.25V20H5.5V18.25M0,20V18.5C0,17.11 1.89,15.94 4.45,15.6C3.86,16.28 3.5,17.22 3.5,18.25V20H0M24,20H20.5V18.25C20.5,17.22 20.14,16.28 19.55,15.6C22.11,15.94 24,17.11 24,18.5V20Z"/>
                    </svg>
                    </div>
                    <div class="metric-label">Total Device Fleet</div>
                    <div class="metric-value" id="totalDevices">0</div>
                    <div class="metric-description">Mobile devices only (Windows excluded)</div>
                </div>
            </div>

            <div class="compliance-section">
                <div class="card">
                    <div class="card-header">
                        <h2>Compliance Overview</h2>
                    </div>
                    <div class="card-body">
                        <div class="compliance-grid">
                            <div class="compliance-card">
                                <div class="compliance-header">
                                    <div class="compliance-title">iOS Compliance</div>
                                    <div class="compliance-percentage" id="iosCompliancePercent">0%</div>
                                </div>
                                <div class="compliance-bar-container">
                                    <div class="compliance-bar-fill" id="iosComplianceFill"></div>
                                </div>
                                <div class="compliance-stats">
                                    <div class="compliance-stat">
                                        <div class="compliance-stat-value" id="iosCompliantCount">0</div>
                                        <div class="compliance-stat-label">Compliant</div>
                                    </div>
                                    <div class="compliance-stat">
                                        <div class="compliance-stat-value" id="iosNonCompliantCount">0</div>
                                        <div class="compliance-stat-label">Non-Compliant</div>
                                    </div>
                                    <div class="compliance-stat">
                                        <div class="compliance-stat-value" id="iosUnknownCount">0</div>
                                        <div class="compliance-stat-label">Unknown</div>
                                    </div>
                                </div>
                            </div>
                            <div class="compliance-card">
                                <div class="compliance-header">
                                    <div class="compliance-title">Android Compliance</div>
                                    <div class="compliance-percentage" id="androidCompliancePercent">0%</div>
                                </div>
                                <div class="compliance-bar-container">
                                    <div class="compliance-bar-fill" id="androidComplianceFill"></div>
                                </div>
                                <div class="compliance-stats">
                                    <div class="compliance-stat">
                                        <div class="compliance-stat-value" id="androidCompliantCount">0</div>
                                        <div class="compliance-stat-label">Compliant</div>
                                    </div>
                                    <div class="compliance-stat">
                                        <div class="compliance-stat-value" id="androidNonCompliantCount">0</div>
                                        <div class="compliance-stat-label">Non-Compliant</div>
                                    </div>
                                    <div class="compliance-stat">
                                        <div class="compliance-stat-value" id="androidUnknownCount">0</div>
                                        <div class="compliance-stat-label">Unknown</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Platform Trend Comparison -->
            <div class="section">
                <div class="section-header">Platform Trend Comparison</div>
                <div class="section-body">
                    <!-- Monthly Count Input Fields -->
                    <div class="card" style="margin-bottom: var(--space-lg); background: var(--neutral-50);">
                        <div class="card-body">
                            <h4 style="color: var(--primary-blue); margin-bottom: var(--space-md); font-size: var(--text-base); font-weight: 600;">Monthly Device Counts</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                            <!-- iOS Monthly Counts -->
                            <div>
                                <h5 style="color: var(--accent-blue); margin-bottom: var(--space-sm); font-size: var(--text-sm); font-weight: 600;">iOS Device Counts</h5>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-sm);">
                                    <div>
                                        <label for="ios_march2025" style="display: block; margin-bottom: var(--space-xs); font-weight: 500; font-size: var(--text-sm); color: var(--neutral-700);">March 2025:</label>
                                        <input type="number" id="ios_march2025" placeholder="Count" style="width: 100%; padding: var(--space-sm); border: 1px solid var(--neutral-300); border-radius: var(--radius-sm); font-size: var(--text-sm);" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div>
                                        <label for="ios_april2025" style="display: block; margin-bottom: 0.2rem; font-weight: 600;">April 2025:</label>
                                        <input type="number" id="ios_april2025" placeholder="Count" style="width: 100%; padding: 0.4rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.7rem;" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div>
                                        <label for="ios_may2025" style="display: block; margin-bottom: 0.2rem; font-weight: 600;">May 2025:</label>
                                        <input type="number" id="ios_may2025" placeholder="Count" style="width: 100%; padding: 0.4rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.7rem;" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div>
                                        <label for="ios_june2025" style="display: block; margin-bottom: 0.2rem; font-weight: 600;">June 2025:</label>
                                        <input type="number" id="ios_june2025" placeholder="Count" style="width: 100%; padding: 0.4rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.7rem;" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div style="grid-column: 1 / -1;">
                                        <label for="ios_current" style="display: block; margin-bottom: 0.2rem; font-weight: 600; color: #0056b3;">Current Month:</label>
                                        <input type="number" id="ios_current" placeholder="Current Count" style="width: 100%; padding: 0.4rem; border: 2px solid #0056b3; border-radius: 4px; font-size: 0.7rem; font-weight: bold;" onchange="updateMonthlyComparison()">
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Android Monthly Counts -->
                            <div>
                                <h5 style="color: #28a745; margin-bottom: 0.8rem; font-size: 0.8rem;">Android Device Counts</h5>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.75rem;">
                                    <div>
                                        <label for="android_march2025" style="display: block; margin-bottom: 0.2rem; font-weight: 600;">March 2025:</label>
                                        <input type="number" id="android_march2025" placeholder="Count" style="width: 100%; padding: 0.4rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.7rem;" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div>
                                        <label for="android_april2025" style="display: block; margin-bottom: 0.2rem; font-weight: 600;">April 2025:</label>
                                        <input type="number" id="android_april2025" placeholder="Count" style="width: 100%; padding: 0.4rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.7rem;" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div>
                                        <label for="android_may2025" style="display: block; margin-bottom: 0.2rem; font-weight: 600;">May 2025:</label>
                                        <input type="number" id="android_may2025" placeholder="Count" style="width: 100%; padding: 0.4rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.7rem;" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div>
                                        <label for="android_june2025" style="display: block; margin-bottom: 0.2rem; font-weight: 600;">June 2025:</label>
                                        <input type="number" id="android_june2025" placeholder="Count" style="width: 100%; padding: 0.4rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.7rem;" onchange="updateMonthlyComparison()">
                                    </div>
                                    <div style="grid-column: 1 / -1;">
                                        <label for="android_current" style="display: block; margin-bottom: 0.2rem; font-weight: 600; color: #28a745;">Current Month:</label>
                                        <input type="number" id="android_current" placeholder="Current Count" style="width: 100%; padding: 0.4rem; border: 2px solid #28a745; border-radius: 4px; font-size: 0.7rem; font-weight: bold;" onchange="updateMonthlyComparison()">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="margin-top: var(--space-lg); display: flex; gap: var(--space-md); justify-content: center; flex-wrap: wrap;">
                            <button onclick="autoFillCurrentCounts()" class="btn btn-primary">
                                <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M19,8L15,12H18A6,6 0 0,1 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20A8,8 0 0,0 20,12H23M6,12A6,6 0 0,1 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4A8,8 0 0,0 4,12H1L5,16L9,12"/>
                                </svg>
                                Auto-Fill Current
                            </button>
                            <button onclick="clearMonthlyCounts()" class="btn btn-secondary">Clear All</button>
                            <button onclick="exportHistoricalData()" class="btn btn-primary" style="background-color: var(--success-green);">
                                <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z"/>
                                </svg>
                                Export CSV
                            </button>
                        </div>
                    </div>
                </div>
                    
                    <div id="monthlyComparison">
                        <!-- Platform comparison table will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Device Details & Lifecycle -->
            <div class="section">
                <div class="section-header">Device Categories & Lifecycle Status</div>
                <div class="section-body">
                    <div class="three-column">
                        <div class="card">
                            <div class="card-header">
                                <h3 style="font-size: var(--text-base); font-weight: 600;">iOS Devices</h3>
                            </div>
                            <div class="card-body">
                                <table class="data-table" id="iosTable">
                                    <thead>
                                        <tr><th>Category</th><th>Count</th></tr>
                                    </thead>
                                    <tbody></tbody>
                                </table>
                                <div style="margin-top: var(--space-md); padding-top: var(--space-md); border-top: 1px solid var(--neutral-200);">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm);">
                                        <span style="font-size: var(--text-sm); color: var(--neutral-600);">Compliance Rate</span>
                                        <span style="font-size: var(--text-lg); font-weight: 600; color: var(--success-green);" id="iosCompliancePercent2">0%</span>
                                    </div>
                                    <div class="compliance-bar-container">
                                        <div class="compliance-bar-fill" id="iosComplianceFill2"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    <div>
                        <h4 style="color: #003d5c; margin-bottom: 0.5rem; font-size: 0.8rem;">Android Device Categories</h4>
                        <table id="androidTable">
                            <thead>
                                <tr><th>Category</th><th>Count</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div style="margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px solid #e9ecef;">
                            <h5 style="color: #003d5c; font-size: 0.75rem; margin-bottom: 0.3rem;">Android Compliance</h5>
                            <p style="font-size: 0.7rem;"><strong>Compliant:</strong> <span id="androidCompliantCount">0</span> | <strong>Non-Compliant:</strong> <span id="androidNonCompliantCount">0</span></p>
                            <div class="compliance-bar-container">
                                <div class="compliance-bar-fill" id="androidComplianceFill"></div>
                            </div>
                            <p style="text-align: center; font-size: 0.7rem;"><strong><span id="androidCompliancePercent">0%</span> Compliance</strong></p>
                        </div>
                    </div>
                    <div>
                        <h4 style="color: #003d5c; margin-bottom: 0.5rem; font-size: 0.8rem;">iOS Device Lifecycle (Key Models)</h4>
                        <table id="lifecycleTable">
                            <thead>
                                <tr><th>Device Model</th><th>Count</th><th>EOL</th><th>Status</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Windows ConfigMgr & Special Categories Section -->
            <div class="section" id="windowsSpecialSection" style="display: none;">
                <div class="section-header">
                    <h2>Windows & Special Categories</h2>
                </div>
                <div class="two-column" style="padding: 0.8rem;">
                    <div>
                        <h4 style="color: #003d5c; margin-bottom: 0.5rem; font-size: 0.8rem;">ConfigMgr Managed Devices</h4>
                        <div class="special-info-card" style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 0.8rem; border-radius: 4px; margin-bottom: 0.5rem;">
                            <p style="margin: 0; font-size: 0.75rem; color: #856404;">
                                <strong>See ConfigMgr:</strong> <span id="configMgrCount" style="font-size: 1.2rem; font-weight: bold;">0</span> devices
                            </p>
                            <p style="margin: 0.3rem 0 0 0; font-size: 0.65rem; color: #856404;">
                                These devices are managed through System Center Configuration Manager
                            </p>
                        </div>
                        <h4 style="color: #003d5c; margin-bottom: 0.5rem; font-size: 0.8rem; margin-top: 1rem;">Unassigned Categories</h4>
                        <div class="special-info-card" style="background: #f8d7da; border: 1px solid #f5c6cb; padding: 0.8rem; border-radius: 4px;">
                            <p style="margin: 0; font-size: 0.75rem; color: #721c24;">
                                <strong>Unassigned:</strong> <span id="unassignedCount" style="font-size: 1.2rem; font-weight: bold;">0</span> devices
                            </p>
                            <p style="margin: 0.3rem 0 0 0; font-size: 0.65rem; color: #721c24;">
                                Devices without assigned categories requiring review
                            </p>
                        </div>
                    </div>
                    <div>
                        <h4 style="color: #003d5c; margin-bottom: 0.5rem; font-size: 0.8rem;">Windows Device Categories</h4>
                        <table id="windowsTable">
                            <thead>
                                <tr><th>Category</th><th>Count</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div style="margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px solid #e9ecef;">
                            <h5 style="color: #003d5c; font-size: 0.75rem; margin-bottom: 0.3rem;">Windows Compliance</h5>
                            <p style="font-size: 0.7rem;"><strong>Compliant:</strong> <span id="windowsCompliantCount">0</span> | <strong>Unknown (ConfigMgr):</strong> <span id="windowsConfigMgrCount">0</span> | <strong>Non-Compliant:</strong> <span id="windowsNonCompliantCount">0</span></p>
                            <div class="compliance-bar-container">
                                <div class="compliance-bar-fill" id="windowsComplianceFill"></div>
                            </div>
                            <p style="text-align: center; font-size: 0.7rem;"><strong><span id="windowsCompliancePercent">0%</span> Intune Compliance</strong></p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Operating System Breakdown -->
            <div class="section">
                <div class="section-header">
                    <h2>Operating System Breakdown</h2>
                </div>
                <div class="section-body">
                    <table class="data-table" id="osTable">
                        <thead>
                            <tr>
                                <th>Operating System</th>
                                <th>Count</th>
                                <th>Percentage</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="urgent-items">
                <h2>Urgent Items</h2>
                <div id="urgentItems"></div>
            </div>
        </div>
        
        <div class="footer">
            <p>&copy; 2025 Tallahassee Memorial Hospital - IT Asset Management Report</p>
            <p>Generated on <span id="reportDate"></span></p>
        </div>
    </div>

    <!-- Modal components removed to clean up layout - functionality can be re-added if needed -->

    <script>
        // Remove all MSAL and Intune live connection code

        // Add this before the file input event listener
        const columnMappings = {
            // Only look for these specific column names exactly as specified
            deviceName: ['Device name'],
            managedBy: ['Managed by'],
            ownership: ['Ownership'],
            complianceStateKey: ['Compliance'],
            osVersion: ['OS version'],
            lastSyncDateTime: ['Last check-in'],
            deviceCategoryKey: ['Category'],
            model: ['Model']
        };

        let workbookGlobal = null;

        function findColumnIndex(headers, possibleNames) {
            for (const name of possibleNames) {
                const index = headers.findIndex(h => 
                    h && h.toString().toLowerCase() === name.toLowerCase()
                );
                if (index !== -1) return index;
            }
            return -1;
        }

        function mapColumns(headers) {
            const columnMap = {};
            let foundColumns = [];

            // Map each column (all optional now)
            for (const [key, possibleNames] of Object.entries(columnMappings)) {
                const index = findColumnIndex(headers, possibleNames);
                if (index !== -1) {
                    columnMap[key] = index;
                    foundColumns.push(key);
                }
            }

            return { columnMap, foundColumns };
        }

        function populateSheetSelector(workbook) {
            const sheetSelect = document.getElementById('sheetSelect');
            const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
            
            sheetSelect.innerHTML = '';
            
            if (workbook.SheetNames.length > 1) {
                workbook.SheetNames.forEach(sheetName => {
                    const option = document.createElement('option');
                    option.value = sheetName;
                    option.textContent = sheetName;
                    sheetSelect.appendChild(option);
                });
                sheetSelectorContainer.style.display = 'block';
            } else {
                sheetSelectorContainer.style.display = 'none';
            }
        }

        function processSelectedSheet() {
            if (!workbookGlobal) return;
            
            const sheetSelect = document.getElementById('sheetSelect');
            const selectedSheet = sheetSelect.value;
            
            // Update status to show processing
            document.getElementById('statusMessage').textContent = `Processing sheet: ${selectedSheet}...`;
            document.getElementById('statusMessage').className = 'status-message status-processing';
            
            try {
                const sheet = workbookGlobal.Sheets[selectedSheet];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                
                // Get headers and map columns
                const headers = jsonData[0];
                const { columnMap, foundColumns } = mapColumns(headers);
                
                console.log('Processing sheet:', selectedSheet);
                console.log('Found columns:', foundColumns);
                
                // Transform data using column mapping
                const mappedData = jsonData.slice(1).map(row => {
                    const mappedRow = {};
                    for (const [key, index] of Object.entries(columnMap)) {
                        mappedRow[key] = row[index];
                    }
                    return mappedRow;
                });
                
                // Process the data and regenerate the report
                processExcelData(mappedData, foundColumns);
            } catch (error) {
                console.error('Error processing sheet:', error);
                document.getElementById('statusMessage').textContent = `Error processing sheet: ${error.message}`;
                document.getElementById('statusMessage').className = 'status-message status-error';
            }
        }

        function regenerateReport() {
            if (!workbookGlobal) {
                alert('Please upload a file first. Note: CSV files cannot be regenerated - please re-upload the file.');
                return;
            }
            
            // Get the currently selected sheet
            const sheetSelect = document.getElementById('sheetSelect');
            const selectedSheet = sheetSelect.value || workbookGlobal.SheetNames[0];
            
            // Update status
            document.getElementById('statusMessage').textContent = `Regenerating report from sheet: ${selectedSheet}...`;
            document.getElementById('statusMessage').className = 'status-message status-processing';
            
            try {
                const sheet = workbookGlobal.Sheets[selectedSheet];
                const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                
                // Get headers and map columns
                const headers = jsonData[0];
                const { columnMap, foundColumns } = mapColumns(headers);
                
                console.log('Regenerating report from sheet:', selectedSheet);
                console.log('Found columns:', foundColumns);
                
                // Transform data using column mapping
                const mappedData = jsonData.slice(1).map(row => {
                    const mappedRow = {};
                    for (const [key, index] of Object.entries(columnMap)) {
                        mappedRow[key] = row[index];
                    }
                    return mappedRow;
                });
                
                // Process the data and regenerate the report
                processExcelData(mappedData, foundColumns);
            } catch (error) {
                console.error('Error regenerating report:', error);
                document.getElementById('statusMessage').textContent = `Error regenerating report: ${error.message}`;
                document.getElementById('statusMessage').className = 'status-message status-error';
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const row = [];
                let current = '';
                let inQuotes = false;
                
                for (let j = 0; j < line.length; j++) {
                    const char = line[j];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        row.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                row.push(current.trim());
                result.push(row);
            }
            
            return result;
        }

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const fileName = file.name;
            const fileExtension = fileName.toLowerCase().split('.').pop();
            document.getElementById('fileName').textContent = fileName;
            document.getElementById('statusMessage').textContent = 'Processing file...';
            document.getElementById('statusMessage').className = 'status-message status-processing';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let jsonData;
                    
                    if (fileExtension === 'csv') {
                        // Process CSV file
                        console.log('Processing CSV file');
                        const csvText = e.target.result;
                        jsonData = parseCSV(csvText);
                        
                        // For CSV, we don't have sheets, so hide sheet selector
                        const sheetSelectorContainer = document.getElementById('sheetSelectorContainer');
                        if (sheetSelectorContainer) {
                            sheetSelectorContainer.style.display = 'none';
                        }
                        workbookGlobal = null; // No workbook for CSV
                        
                    } else {
                        // Process Excel file
                        console.log('Processing Excel file');
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        workbookGlobal = workbook;
                        
                        // Populate sheet selector
                        populateSheetSelector(workbook);
                        
                        // Process the first sheet by default
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                    }
                    
                    // Get headers and map columns
                    const headers = jsonData[0];
                    const { columnMap, foundColumns } = mapColumns(headers);
                    
                    console.log('Found columns:', foundColumns);
                    console.log('Headers:', headers);
                    
                    // Show a status message about what columns were found
                    const statusMsg = `Found ${foundColumns.length} recognized columns: ${foundColumns.join(', ')}`;
                    document.getElementById('statusMessage').textContent = statusMsg;
                    document.getElementById('statusMessage').className = 'status-message status-processing';

                    // Transform data using column mapping
                    const mappedData = jsonData.slice(1).map(row => {
                        const mappedRow = {};
                        for (const [key, index] of Object.entries(columnMap)) {
                            mappedRow[key] = row[index];
                        }
                        return mappedRow;
                    });
                    
                    processExcelData(mappedData, foundColumns);
                } catch (error) {
                    console.error('Error processing file:', error);
                    document.getElementById('statusMessage').textContent = `Error: ${error.message}`;
                    document.getElementById('statusMessage').className = 'status-message status-error';
                }
            };
            
            // Read file based on type
            if (fileExtension === 'csv') {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        });

        // Add event listener for sheet selection
        document.addEventListener('DOMContentLoaded', function() {
            const sheetSelect = document.getElementById('sheetSelect');
            if (sheetSelect) {
                sheetSelect.addEventListener('change', function() {
                    console.log('Sheet selection changed to:', sheetSelect.value);
                    processSelectedSheet();
                });
            }
        });

        async function processExcelData(data, foundColumns = []) {
            try {
                console.log('Processing data:', data.length, 'devices');
                console.log('Available columns:', foundColumns);
                console.log('Sample data row:', data[0]);
                
                // Store data globally for debug function
                window.lastProcessedData = data;
                window.lastFoundColumns = foundColumns;
                
                // Clear previous report data
                clearReportData();
                
                // Filter out deleted devices (if isDeleted column exists)
                let filteredDevices = foundColumns.includes('isDeleted') ? 
                    data.filter(device => !device.isDeleted) : data;
                console.log('Devices after filtering deleted:', filteredDevices.length);
                
                // Filter out Windows devices from Intune exports
                const activeDevices = filteredDevices.filter(device => {
                    // Check various fields that might contain OS information
                    const deviceStr = JSON.stringify(device).toLowerCase();
                    const osVersion = device.osVersion ? device.osVersion.toString().toLowerCase() : '';
                    const operatingSystem = device.operatingSystem ? device.operatingSystem.toString().toLowerCase() : '';
                    const model = device.model ? device.model.toString().toLowerCase() : '';
                    const manufacturer = device.manufacturer ? device.manufacturer.toString().toLowerCase() : '';
                    
                    // Return false (exclude) if device appears to be Windows
                    const isWindows = osVersion.includes('windows') || 
                                     operatingSystem.includes('windows') ||
                                     deviceStr.includes('windows') ||
                                     deviceStr.includes('microsoft') ||
                                     manufacturer.includes('microsoft') ||
                                     model.includes('surface') ||
                                     deviceStr.includes('win10') ||
                                     deviceStr.includes('win11');
                    
                    if (isWindows) {
                        console.log('Excluding Windows device:', device.displayName || device.deviceName || 'Unknown device');
                    }
                    
                    return !isWindows; // Return true to include, false to exclude
                });
                
                const excludedCount = filteredDevices.length - activeDevices.length;
                console.log(`Excluded ${excludedCount} Windows devices from processing`);
                console.log('Active devices (non-Windows):', activeDevices.length);
                
                // Filter out personal devices from all counts
                const nonPersonalDevices = activeDevices.filter(device => {
                    if (foundColumns.includes('deviceCategoryKey') && device.deviceCategoryKey) {
                        const category = device.deviceCategoryKey.toString().toLowerCase();
                        
                        // More specific personal device detection to avoid false positives
                        if (category.includes('personal') && 
                            !category.includes('backstock') && 
                            !category.includes('back stock') &&
                            !category.includes('corporate') &&
                            !category.includes('company') &&
                            !category.includes('business')) {
                            console.log('Excluding personal device:', device.deviceName || device.displayName || 'Unknown device', 'Category:', category);
                            return false;
                        }
                        
                        // Explicitly include BackStock devices (they are NOT personal)
                        if (category.includes('backstock') || category.includes('back stock')) {
                            console.log('Including BackStock device:', device.deviceName || device.displayName || 'Unknown device', 'Category:', category);
                            return true;
                        }
                    }
                    return true;
                });
                
                const personalExcludedCount = activeDevices.length - nonPersonalDevices.length;
                console.log(`Excluded ${personalExcludedCount} personal devices from processing`);
                console.log('Non-personal devices:', nonPersonalDevices.length);
                
                // Debug: Check for BackStock devices specifically
                const backstockDevices = activeDevices.filter(device => {
                    if (foundColumns.includes('deviceCategoryKey') && device.deviceCategoryKey) {
                        const category = device.deviceCategoryKey.toString().toLowerCase();
                        return category.includes('backstock') || category.includes('back stock');
                    }
                    return false;
                });
                console.log(`Found ${backstockDevices.length} BackStock devices in active devices`);
                
                const backstockInNonPersonal = nonPersonalDevices.filter(device => {
                    if (foundColumns.includes('deviceCategoryKey') && device.deviceCategoryKey) {
                        const category = device.deviceCategoryKey.toString().toLowerCase();
                        return category.includes('backstock') || category.includes('back stock');
                    }
                    return false;
                });
                console.log(`Found ${backstockInNonPersonal.length} BackStock devices in non-personal devices`);
                
                if (backstockDevices.length !== backstockInNonPersonal.length) {
                    console.warn('WARNING: Some BackStock devices may have been incorrectly filtered out!');
                }
                
                // Store global devices data for modal windows
                globalDevicesData = nonPersonalDevices;
                
                // Calculate critical metrics using OS version column
                let iosDevices = [], androidDevices = [];
                
                console.log('Detecting OS from available data...');
                nonPersonalDevices.forEach((device, index) => {
                    if (index < 3) console.log(`Device ${index}:`, device); // Log first few devices for debugging
                    
                    // Check OS version column first if available
                    let osDetected = false;
                    if (foundColumns.includes('osVersion') && device.osVersion) {
                        const osVersion = device.osVersion.toString().toLowerCase();
                        if (osVersion.includes('ios')) {
                            iosDevices.push(device);
                            osDetected = true;
                        } else if (osVersion.includes('android')) {
                            androidDevices.push(device);
                            osDetected = true;
                        }
                    }
                    
                    // If not detected from OS version, try other fields
                    if (!osDetected) {
                        const deviceStr = JSON.stringify(device).toLowerCase();
                        if (deviceStr.includes('ios') || deviceStr.includes('iphone') || deviceStr.includes('ipad')) {
                            iosDevices.push(device);
                        } else if (deviceStr.includes('android')) {
                            androidDevices.push(device);
                        }
                    }
                });
                
                // Since we're filtering out Windows devices, define as empty array
                const windowsDevices = [];
                const totalDevices = iosDevices.length + androidDevices.length;

                console.log('Device counts after processing:');
                console.log('iOS devices:', iosDevices.length);
                console.log('Android devices:', androidDevices.length);
                console.log('Windows devices (filtered out):', windowsDevices.length);
                console.log('Total devices:', totalDevices);

                // Calculate compliance metrics using Compliance column
                let iosCompliant = 0, androidCompliant = 0, windowsCompliant = 0, nonCompliantDevices = [];
                let configMgrDevices = 0, unassignedDevices = 0;
                
                if (foundColumns.includes('complianceStateKey')) {
                    console.log('Processing compliance data...');
                    
                    // Note: Windows devices are filtered out, so windowsDevices will always be empty
                    console.log('Windows devices (filtered out):', windowsDevices.length);
                    
                    iosCompliant = iosDevices.filter(d => d.complianceStateKey && d.complianceStateKey.toString().toLowerCase().includes('compliant')).length;
                    androidCompliant = androidDevices.filter(d => d.complianceStateKey && d.complianceStateKey.toString().toLowerCase().includes('compliant')).length;
                    
                    // For Windows: separate compliant from ConfigMgr (unknown status)
                    windowsCompliant = windowsDevices.filter(d => {
                        if (!d.complianceStateKey) return false;
                        const complianceStr = d.complianceStateKey.toString().toLowerCase().trim();
                        // Only count as compliant if it contains "compliant" but NOT ConfigMgr terms
                        return complianceStr.includes('compliant') && 
                               !complianceStr.includes('configmgr') && 
                               !complianceStr.includes('config mgr') &&
                               !complianceStr.includes('see configmgr') &&
                               !complianceStr.includes('sccm') &&
                               !complianceStr.includes('configuration manager');
                    }).length;
                    
                    // Count ConfigMgr devices as "unknown" status
                    configMgrDevices = windowsDevices.filter(d => {
                        if (!d.complianceStateKey) return false;
                        const complianceStr = d.complianceStateKey.toString().toLowerCase().trim();
                        return complianceStr.includes('configmgr') || 
                               complianceStr.includes('config mgr') ||
                               complianceStr.includes('see configmgr') ||
                               complianceStr.includes('sccm') ||
                               complianceStr.includes('configuration manager');
                    }).length;
                    
                    // Note: No Windows compliance values to log since Windows devices are filtered out
                    console.log('Windows compliance processing skipped (devices filtered out)');
                    
                    // Calculate non-compliant devices from iOS and Android devices only (not Windows)
                    const mobileDevices = [...iosDevices, ...androidDevices];
                    nonCompliantDevices = mobileDevices.filter(d => !d.complianceStateKey || 
                        (!d.complianceStateKey.toString().toLowerCase().includes('compliant') && 
                         !d.complianceStateKey.toString().toLowerCase().includes('configmgr') &&
                         !d.complianceStateKey.toString().toLowerCase().includes('config mgr') &&
                         !d.complianceStateKey.toString().toLowerCase().includes('sccm')));
                    
                    console.log('Compliance counts - iOS:', iosCompliant, 'Android:', androidCompliant, 'Windows:', windowsCompliant);
                    console.log('All compliance calculations now use consistent .includes("compliant") logic');
                    console.log('ConfigMgr devices:', configMgrDevices);
                    console.log('Non-compliant devices (mobile only):', nonCompliantDevices.length);
                }
                
                // Count unassigned category devices (mobile only)
                if (foundColumns.includes('deviceCategoryKey')) {
                    const mobileDevices = [...iosDevices, ...androidDevices];
                    unassignedDevices = mobileDevices.filter(d => !d.deviceCategoryKey || 
                        d.deviceCategoryKey.toString().toLowerCase().includes('unassigned') ||
                        d.deviceCategoryKey.toString().trim() === '').length;
                    console.log('Unassigned category devices (mobile only):', unassignedDevices);
                }
                
                // Calculate devices not synced in last 90 days for urgent removal (mobile only, excluding backstock)
                let staleDevices = [];
                if (foundColumns.includes('lastSyncDateTime')) {
                    console.log('Processing last check-in data for urgent removal...');
                    const ninetyDaysAgo = new Date();
                    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
                    const mobileDevices = [...iosDevices, ...androidDevices];
                    staleDevices = mobileDevices.filter(d => {
                        // Exclude devices with backstock category
                        if (foundColumns.includes('deviceCategoryKey') && d.deviceCategoryKey) {
                            const category = d.deviceCategoryKey.toString().toLowerCase();
                            if (category.includes('backstock')) {
                                return false; // Exclude backstock devices from alerts
                            }
                        }
                        
                        // Check if device hasn't communicated in 90+ days
                        if (!d.lastSyncDateTime) return true;
                        const lastSync = new Date(d.lastSyncDateTime);
                        return isNaN(lastSync.getTime()) || lastSync < ninetyDaysAgo;
                    });
                    console.log('Devices for urgent removal (90+ days, mobile only, excluding backstock):', staleDevices.length);
                }

                // Update summary cards with critical metrics
                document.getElementById('iosTotal').textContent = iosDevices.length;
                document.getElementById('androidTotal').textContent = androidDevices.length;
                
                // Historical tracking elements removed for professional presentation
                document.getElementById('totalDevices').textContent = totalDevices;

                // Historical tracking functions removed for professional presentation

                // Create urgent items section focusing on end-of-life and support issues
                const urgentItems = [];
                
                // Check for devices with end-of-life issues (iOS devices)
                let eolCriticalDevices = [], eolWarningDevices = [];
                if (iosDevices.length > 0) {
                    iosDevices.forEach(device => {
                        const model = device.model;
                        if (model && iosLifecycle[model]) {
                            const currentYear = new Date().getFullYear();
                            const eolYear = iosLifecycle[model].endOfLife;
                            const yearsLeft = eolYear - currentYear;
                            
                            if (yearsLeft <= 1) {
                                eolCriticalDevices.push(device);
                            } else if (yearsLeft <= 2) {
                                eolWarningDevices.push(device);
                            }
                        }
                    });
                }
                
                if (eolCriticalDevices.length > 0) {
                    urgentItems.push({
                        severity: 'high',
                        title: 'End of Life Critical',
                        count: eolCriticalDevices.length,
                        description: `${eolCriticalDevices.length} devices ending support within 1 year`
                    });
                }
                
                if (eolWarningDevices.length > 0) {
                    urgentItems.push({
                        severity: 'medium',
                        title: 'End of Life Warning',
                        count: eolWarningDevices.length,
                        description: `${eolWarningDevices.length} devices ending support within 2 years`
                    });
                }
                
                // Add compliance issues as secondary priority
                if (foundColumns.includes('complianceStateKey') && nonCompliantDevices.length > 0) {
                    urgentItems.push({
                        severity: 'medium',
                        title: 'Non-Compliant Devices',
                        count: nonCompliantDevices.length,
                        description: `${nonCompliantDevices.length} devices require compliance attention`
                    });
                }
                
                // Add devices for urgent removal as high priority
                if (foundColumns.includes('lastSyncDateTime') && staleDevices.length > 0) {
                    urgentItems.push({
                        severity: 'high',
                        title: 'Urgent Removal',
                        count: staleDevices.length,
                        description: `${staleDevices.length} devices not communicating for 90+ days (backstock excluded)`
                    });
                }
                
                console.log('Urgent items created:', urgentItems.length);
                
                // Update urgent indicator in header
                updateUrgentIndicator(urgentItems);
                
                // Add debugging info for categories (can be removed in production)
                logCategoryDebugInfo(activeDevices, foundColumns);

                // Update compliance bars (only if compliance data exists)
                if (foundColumns.includes('complianceStateKey')) {
                    const iosCompliancePercent = iosDevices.length > 0 ? (iosCompliant / iosDevices.length) * 100 : 0;
                    const androidCompliancePercent = androidDevices.length > 0 ? (androidCompliant / androidDevices.length) * 100 : 0;
                    
                    // Update iOS compliance
                    const iosComplianceElement = document.getElementById('iosCompliant');
                    const iosComplianceTextElement = document.getElementById('iosComplianceText');
                    if (iosComplianceElement && iosComplianceTextElement) {
                        iosComplianceElement.style.width = `${iosCompliancePercent}%`;
                        iosComplianceTextElement.textContent = `${iosCompliancePercent.toFixed(1)}% (${iosCompliant}/${iosDevices.length})`;
                    }
                    
                    // Update Android compliance
                    const androidComplianceElement = document.getElementById('androidCompliant');
                    const androidComplianceTextElement = document.getElementById('androidComplianceText');
                    if (androidComplianceElement && androidComplianceTextElement) {
                        androidComplianceElement.style.width = `${androidCompliancePercent}%`;
                        androidComplianceTextElement.textContent = `${androidCompliancePercent.toFixed(1)}% (${androidCompliant}/${androidDevices.length})`;
                    }
                } else {
                    // Hide compliance section if no compliance data
                    const complianceSection = document.querySelector('.compliance-section');
                    if (complianceSection) {
                        complianceSection.style.display = 'none';
                    }
                }

                // Update urgent items section
                const urgentItemsContainer = document.getElementById('urgentItems');
                if (urgentItemsContainer) {
                    urgentItemsContainer.innerHTML = '';
                    
                    if (urgentItems.length === 0) {
                        urgentItemsContainer.innerHTML = '<div class="no-urgent-items">No urgent items requiring attention</div>';
                    } else {
                        urgentItems.forEach(item => {
                            const itemElement = document.createElement('div');
                            itemElement.className = `urgent-item ${item.severity}`;
                            itemElement.innerHTML = `
                                <h3>${item.title}</h3>
                                <div class="count">${item.count}</div>
                                <p>${item.description}</p>
                            `;
                            urgentItemsContainer.appendChild(itemElement);
                        });
                    }
                }

                // Always populate tables if we have device data
                if (totalDevices > 0) {
                    populateOSTable(activeDevices);
                    populateDeviceCategoriesTables(activeDevices, foundColumns, iosDevices, androidDevices);
                } else {
                    // Hide sections if no device data
                    const osSection = document.getElementById('osTable')?.closest('.section');
                    if (osSection) osSection.style.display = 'none';
                }

                // Populate lifecycle table with iOS devices if we have any
                if (iosDevices.length > 0) {
                    populateLifecycleTable(iosDevices);
                }

                // Show report container
                const reportContainer = document.getElementById('reportContainer');
                if (reportContainer) {
                    reportContainer.style.display = 'block';
                }
                
                // Update status message with category info
                const statusMessage = document.getElementById('statusMessage');
                if (statusMessage) {
                    let message = `Report generated successfully with ${foundColumns.length} data columns`;
                    
                    // Add Windows exclusion info
                    if (excludedCount > 0) {
                        message += ` • Excluded ${excludedCount} Windows devices from processing`;
                    }
                    
                    // Add category detection info
                    if (foundColumns.includes('deviceCategoryKey')) {
                        const androidDevices = activeDevices.filter(d => {
                            const deviceStr = JSON.stringify(d).toLowerCase();
                            return deviceStr.includes('android');
                        });
                        
                        const specialCategories = [];
                        androidDevices.forEach(device => {
                            if (device.deviceCategoryKey) {
                                const cat = device.deviceCategoryKey.toString().toLowerCase();
                                if (cat.includes('backstock') && !specialCategories.includes('Backstock')) {
                                    specialCategories.push('Backstock');
                                }
                                if ((cat.includes('epic welcome') || cat.includes('epic-welcome') || cat.includes('epicwelcome')) 
                                    && !specialCategories.includes('Epic Welcome')) {
                                    specialCategories.push('Epic Welcome');
                                }
                            }
                        });
                        
                        if (specialCategories.length > 0) {
                            message += ` • Found: ${specialCategories.join(', ')}`;
                        }
                    }
                    
                    statusMessage.textContent = message;
                    statusMessage.className = 'status-message status-success';
                }
                
                console.log('Report generated successfully');
            } catch (error) {
                console.error('Error processing data:', error);
                const statusMessage = document.getElementById('statusMessage');
                if (statusMessage) {
                    statusMessage.textContent = `Error: ${error.message}`;
                    statusMessage.className = 'status-message status-error';
                }
            }
        }

        function populateOSTable(devices) {
            const osTable = document.getElementById('osTable');
            if (!osTable) return;
            
            const tbody = osTable.getElementsByTagName('tbody')[0];
            if (!tbody) return;
            
            tbody.innerHTML = '';

            // Count devices by operating system
            const osCounts = {};
            devices.forEach(device => {
                const os = device.operatingSystem || 'Unknown';
                osCounts[os] = (osCounts[os] || 0) + 1;
            });

            // Sort by count (descending)
            const sortedOS = Object.entries(osCounts).sort((a, b) => b[1] - a[1]);

            sortedOS.forEach(([os, count]) => {
                const percentage = ((count / devices.length) * 100).toFixed(1);
                const row = tbody.insertRow();
                row.insertCell(0).textContent = os;
                row.insertCell(1).textContent = count;
                row.insertCell(2).textContent = `${percentage}%`;
            });
        }

        function populateDeviceCategoriesTables(devices, foundColumns, iosDevices = [], androidDevices = []) {
            // Use provided device arrays if available, otherwise filter from all devices
            if (iosDevices.length === 0 && androidDevices.length === 0) {
                iosDevices = devices.filter(d => 
                    d.operatingSystem && d.operatingSystem.toString().toLowerCase().includes('ios')
                );
                androidDevices = devices.filter(d => 
                    d.operatingSystem && d.operatingSystem.toString().toLowerCase().includes('android')
                );
            }

            console.log('Populating category tables - iOS:', iosDevices.length, 'Android:', androidDevices.length);

            // Populate iOS categories table
            populateIOSCategoriesTable(iosDevices, foundColumns);
            
            // Populate Android categories table  
            populateAndroidCategoriesTable(androidDevices, foundColumns);
        }

        function updateSpecialCounts(configMgrDevices, unassignedDevices, windowsDevices, foundColumns) {
            // Update ConfigMgr count
            const configMgrElement = document.getElementById('configMgrCount');
            if (configMgrElement) {
                configMgrElement.textContent = configMgrDevices;
            }
            
            // Update unassigned count
            const unassignedElement = document.getElementById('unassignedCount');
            if (unassignedElement) {
                unassignedElement.textContent = unassignedDevices;
            }
            
            // Show/hide the Windows special section based on whether we have Windows devices or special counts
            const windowsSpecialSection = document.getElementById('windowsSpecialSection');
            if (windowsSpecialSection) {
                if (windowsDevices.length > 0 || configMgrDevices > 0 || unassignedDevices > 0) {
                    windowsSpecialSection.style.display = 'block';
                } else {
                    windowsSpecialSection.style.display = 'none';
                }
            }
            
            console.log('Updated special counts - ConfigMgr:', configMgrDevices, 'Unassigned:', unassignedDevices);
        }

        function populateIOSCategoriesTable(iosDevices, foundColumns) {
            const iosTable = document.getElementById('iosTable');
            if (!iosTable) return;
            
            const tbody = iosTable.getElementsByTagName('tbody')[0];
            if (!tbody) return;
            
            tbody.innerHTML = '';

            console.log('Populating iOS categories table with', iosDevices.length, 'devices');

            // Count devices by Category column with enhanced categorization
            const categoryCounts = {};
            iosDevices.forEach((device, index) => {
                let category = '(no category)';
                
                // Use the Category column if available
                if (foundColumns.includes('deviceCategoryKey') && device.deviceCategoryKey) {
                    // Clean and normalize the category name
                    let rawCategory = device.deviceCategoryKey.toString().trim();
                    
                    // Handle specific TMH categories (case-insensitive)
                    const lowerCategory = rawCategory.toLowerCase();
                    
                    // Enhanced debugging for category mapping
                    if (index < 10) {
                        console.log(`iOS Device ${index} category mapping:`, {
                            original: rawCategory,
                            lowercase: lowerCategory,
                            device: device.deviceName || device.displayName || 'Unknown'
                        });
                    }
                    
                    if (lowerCategory.includes('backstock') || lowerCategory.includes('back stock')) {
                        category = 'iOS Backstock';
                    } else if (lowerCategory.includes('epic welcome') || lowerCategory.includes('epic-welcome') || lowerCategory.includes('epicwelcome') || lowerCategory.includes('epic_welcome')) {
                        category = 'Epic Welcome';
                    } else if (lowerCategory.includes('zebra') || lowerCategory.includes('scanner') || lowerCategory.includes('barcode')) {
                        category = 'Zebra/Scanner';
                    } else if (lowerCategory.includes('tablet') || lowerCategory.includes('ipad')) {
                        category = 'iPad';
                    } else if (lowerCategory.includes('phone') || lowerCategory.includes('mobile phone')) {
                        category = 'iPhone';
                    } else if (lowerCategory.includes('kiosk') || lowerCategory.includes('self-service')) {
                        category = 'Kiosk';
                    } else if (lowerCategory.includes('rugged') || lowerCategory.includes('industrial')) {
                        category = 'Rugged Device';
                    } else if (lowerCategory.includes('mobile') && !lowerCategory.includes('phone')) {
                        category = 'Mobile Device';
                    } else if (lowerCategory.includes('test') || lowerCategory.includes('testing') || lowerCategory.includes('pilot')) {
                        category = 'Test Device';
                    } else if (lowerCategory.includes('demo') || lowerCategory.includes('demonstration') || lowerCategory.includes('sample')) {
                        category = 'Demo Device';
                    } else if (lowerCategory.includes('pool') || lowerCategory.includes('shared') || lowerCategory.includes('common')) {
                        category = 'Shared/Pool Device';
                    } else if (lowerCategory.includes('corporate') || lowerCategory.includes('company') || lowerCategory.includes('business')) {
                        category = 'Corporate Device';
                    } else if (lowerCategory.includes('nurse') || lowerCategory.includes('nursing') || lowerCategory.includes('clinical')) {
                        category = 'Nursing Device';
                    } else if (lowerCategory.includes('physician') || lowerCategory.includes('doctor') || lowerCategory.includes('provider') || lowerCategory.includes('medical')) {
                        category = 'Provider Device';
                    } else if (lowerCategory.includes('admin') || lowerCategory.includes('administration') || lowerCategory.includes('office')) {
                        category = 'Administrative Device';
                    } else if (lowerCategory.includes('emergency') || lowerCategory.includes('er') || lowerCategory.includes('trauma') || lowerCategory.includes('urgent')) {
                        category = 'Emergency/Trauma Device';
                    } else if (lowerCategory.includes('surgery') || lowerCategory.includes('surgical') || lowerCategory.includes('or') || lowerCategory.includes('operating')) {
                        category = 'Surgical Device';
                    } else if (lowerCategory.includes('unassigned') || lowerCategory === '' || lowerCategory === 'null' || lowerCategory === 'none') {
                        category = '(unassigned)';
                    } else {
                        // Use the original category name if no specific mapping found
                        category = rawCategory;
                    }
                } else if (foundColumns.includes('deviceCategoryKey')) {
                    category = '(blank)';
                } else {
                    // If no Category column found, categorize by device type
                    const deviceStr = JSON.stringify(device).toLowerCase();
                    if (deviceStr.includes('ipad')) {
                        category = 'iPad';
                    } else if (deviceStr.includes('iphone')) {
                        category = 'iPhone';
                    } else {
                        category = 'iOS Device';
                    }
                }
                
                if (index < 3) console.log(`iOS Device ${index} category:`, category, 'from device:', device);
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });

            console.log('iOS category counts:', categoryCounts);

            // Sort by count (descending)
            const sortedCategories = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);

            sortedCategories.forEach(([category, count]) => {
                const row = tbody.insertRow();
                
                // Category cell with improved formatting
                const categoryCell = row.insertCell(0);
                categoryCell.textContent = category;
                
                // Add visual indicators for special categories
                if (category.includes('BackStock') || category.includes('backstock')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#fd7e14';
                } else if (category.includes('Epic Welcome') || category.includes('epic welcome')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#17a745';
                } else if (category.includes('HC50') || category.includes('hc50')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#28a745';
                } else if (category.includes('TC52') || category.includes('tc52') || category.includes('TC50') || category.includes('tc50')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#28a745';
                } else if (category.includes('Rover') || category.includes('rover')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#6f42c1';
                } else if (category.includes('I-Series') || category.includes('i-series')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#20c997';
                } else if (category.includes('Supply') || category.includes('supply')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#fd7e14';
                } else if (category.includes('Test') || category.includes('test')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#ffc107';
                } else if (category.includes('(unassigned)') || category.includes('(blank)') || category.includes('(no category)')) {
                    categoryCell.style.color = '#dc3545';
                    categoryCell.style.fontStyle = 'italic';
                }
                
                // Count cell
                const countCell = row.insertCell(1);
                countCell.textContent = count;
                countCell.style.fontWeight = 'bold';
            });

            // Update iOS compliance - using same logic as main calculation
            if (foundColumns.includes('complianceStateKey')) {
                const compliant = iosDevices.filter(d => d.complianceStateKey && d.complianceStateKey.toString().toLowerCase().includes('compliant')).length;
                const nonCompliant = iosDevices.length - compliant;
                const compliancePercent = iosDevices.length > 0 ? (compliant / iosDevices.length) * 100 : 0;
                
                document.getElementById('iosCompliantCount').textContent = compliant;
                document.getElementById('iosNonCompliantCount').textContent = nonCompliant;
                document.getElementById('iosComplianceFill').style.width = `${compliancePercent}%`;
                document.getElementById('iosCompliancePercent').textContent = `${compliancePercent.toFixed(1)}%`;
            }
        }

        function populateAndroidCategoriesTable(androidDevices, foundColumns) {
            const androidTable = document.getElementById('androidTable');
            if (!androidTable) return;
            
            const tbody = androidTable.getElementsByTagName('tbody')[0];
            if (!tbody) return;
            
            tbody.innerHTML = '';

            console.log('=== ANDROID CATEGORIZATION DEBUG ===');
            console.log('Populating Android categories table with', androidDevices.length, 'devices');
            console.log('Found columns:', foundColumns);
            console.log('deviceCategoryKey column found:', foundColumns.includes('deviceCategoryKey'));

            // Debug: Show all raw Android categories first
            console.log('DEBUG: Raw Android device categories:');
            const rawAndroidCategories = new Set();
            const categorySample = [];
            androidDevices.forEach((device, index) => {
                if (device.deviceCategoryKey) {
                    const rawCat = device.deviceCategoryKey.toString().trim();
                    rawAndroidCategories.add(rawCat);
                    if (index < 10) { // Show first 10 devices for debugging
                        console.log(`Android Device ${index}: "${rawCat}"`);
                        categorySample.push({
                            index,
                            category: rawCat,
                            deviceName: device.deviceName || device.displayName || 'Unknown',
                            fullDevice: device
                        });
                    }
                } else {
                    if (index < 10) {
                        console.log(`Android Device ${index}: (no category)`);
                        categorySample.push({
                            index,
                            category: '(no category)',
                            deviceName: device.deviceName || device.displayName || 'Unknown',
                            fullDevice: device
                        });
                    }
                }
            });
            console.log(`Found ${rawAndroidCategories.size} unique raw Android categories:`, [...rawAndroidCategories]);
            console.log('Sample of first 10 devices with categories:', categorySample);

            // Simple adaptive categorization - use original category names
            const categoryCounts = {};
            const mappingDebug = [];
            androidDevices.forEach((device, index) => {
                let category = '(no category)';
                let mappingReason = 'no category data';
                
                // Use the Category column if available
                if (foundColumns.includes('deviceCategoryKey') && device.deviceCategoryKey) {
                    // Use the original category name as-is
                    category = device.deviceCategoryKey.toString().trim();
                    mappingReason = 'using original category name';
                    
                    // Handle empty/null categories
                    if (category === '' || category === 'null' || category === 'none') {
                        category = '(unassigned)';
                        mappingReason = 'empty/null category';
                    }
                } else if (foundColumns.includes('deviceCategoryKey')) {
                    category = '(blank)';
                    mappingReason = 'deviceCategoryKey column exists but no value';
                } else {
                    // If no Category column found, categorize by device type or model
                    const deviceStr = JSON.stringify(device).toLowerCase();
                    if (deviceStr.includes('zebra') || deviceStr.includes('scanner') || deviceStr.includes('barcode')) {
                        category = 'Zebra/Scanner';
                        mappingReason = 'fallback: device contains zebra/scanner/barcode';
                    } else if (deviceStr.includes('tablet') || deviceStr.includes('ipad')) {
                        category = 'Android Tablet';
                        mappingReason = 'fallback: device contains tablet/ipad';
                    } else if (deviceStr.includes('phone') || deviceStr.includes('mobile phone')) {
                        category = 'Android Phone';
                        mappingReason = 'fallback: device contains phone';
                    } else {
                        category = 'Android Device';
                        mappingReason = 'fallback: generic android device';
                    }
                }
                
                // Enhanced debugging for first few devices
                if (index < 5) {
                    console.log(`Android Device ${index}:`, {
                        originalCategory: device.deviceCategoryKey,
                        mappedCategory: category,
                        mappingReason: mappingReason,
                        device: device.deviceName || device.displayName || 'Unknown'
                    });
                    mappingDebug.push({
                        index,
                        originalCategory: device.deviceCategoryKey,
                        mappedCategory: category,
                        mappingReason: mappingReason,
                        device: device.deviceName || device.displayName || 'Unknown'
                    });
                }
                
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });

            console.log('Android category counts:', categoryCounts);
            console.log('Total unique Android categories found:', Object.keys(categoryCounts).length);
            console.log('Mapping debug for first 5 devices:', mappingDebug);
            console.log('=== END ANDROID CATEGORIZATION DEBUG ===');

            // Sort by count (descending)
            const sortedCategories = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);

            // Enhanced table population with better formatting
            sortedCategories.forEach(([category, count]) => {
                const row = tbody.insertRow();
                
                // Category cell with improved formatting
                const categoryCell = row.insertCell(0);
                categoryCell.textContent = category;
                
                // Add visual indicators for special categories
                if (category.includes('BackStock') || category.includes('backstock')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#fd7e14';
                } else if (category.includes('Epic Welcome') || category.includes('epic welcome')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#17a745';
                } else if (category.includes('HC50') || category.includes('hc50')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#28a745';
                } else if (category.includes('TC52') || category.includes('tc52') || category.includes('TC50') || category.includes('tc50')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#28a745';
                } else if (category.includes('Rover') || category.includes('rover')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#6f42c1';
                } else if (category.includes('I-Series') || category.includes('i-series')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#20c997';
                } else if (category.includes('Supply') || category.includes('supply')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#fd7e14';
                } else if (category.includes('Test') || category.includes('test')) {
                    categoryCell.style.fontWeight = 'bold';
                    categoryCell.style.color = '#ffc107';
                } else if (category.includes('(unassigned)') || category.includes('(blank)') || category.includes('(no category)')) {
                    categoryCell.style.color = '#dc3545';
                    categoryCell.style.fontStyle = 'italic';
                }
                
                // Count cell
                const countCell = row.insertCell(1);
                countCell.textContent = count;
                countCell.style.fontWeight = 'bold';
            });

            // Update Android compliance - using same logic as main calculation
            if (foundColumns.includes('complianceStateKey')) {
                const compliant = androidDevices.filter(d => d.complianceStateKey && d.complianceStateKey.toString().toLowerCase().includes('compliant')).length;
                const nonCompliant = androidDevices.length - compliant;
                const compliancePercent = androidDevices.length > 0 ? (compliant / androidDevices.length) * 100 : 0;
                
                document.getElementById('androidCompliantCount').textContent = compliant;
                document.getElementById('androidNonCompliantCount').textContent = nonCompliant;
                document.getElementById('androidComplianceFill').style.width = `${compliancePercent}%`;
                document.getElementById('androidCompliancePercent').textContent = `${compliancePercent.toFixed(1)}%`;
            }
        }

        function populateWindowsCategoriesTable(windowsDevices, foundColumns) {
            const windowsTable = document.getElementById('windowsTable');
            if (!windowsTable) return;
            
            const tbody = windowsTable.getElementsByTagName('tbody')[0];
            if (!tbody) return;
            
            tbody.innerHTML = '';

            console.log('Populating Windows categories table with', windowsDevices.length, 'devices');

            // Count devices by Category column with enhanced categorization
            const categoryCounts = {};
            windowsDevices.forEach((device, index) => {
                let category = '(no category)';
                
                // Use the Category column if available
                if (foundColumns.includes('deviceCategoryKey') && device.deviceCategoryKey) {
                    let rawCategory = device.deviceCategoryKey.toString().trim();
                    const lowerCategory = rawCategory.toLowerCase();
                    
                    // Handle specific categories
                    if (lowerCategory.includes('unassigned') || lowerCategory === '' || lowerCategory === 'null') {
                        category = '(unassigned)';
                    } else if (lowerCategory.includes('laptop') || lowerCategory.includes('notebook')) {
                        category = 'Laptop';
                    } else if (lowerCategory.includes('desktop') || lowerCategory.includes('workstation')) {
                        category = 'Desktop/Workstation';
                    } else if (lowerCategory.includes('tablet')) {
                        category = 'Windows Tablet';
                    } else if (lowerCategory.includes('kiosk')) {
                        category = 'Kiosk';
                    } else if (lowerCategory.includes('server')) {
                        category = 'Server';
                    } else {
                        // Use the original category name if no specific mapping found
                        category = rawCategory;
                    }
                } else if (foundColumns.includes('deviceCategoryKey')) {
                    category = '(blank)';
                } else {
                    // If no Category column found, categorize by device type
                    const deviceStr = JSON.stringify(device).toLowerCase();
                    if (deviceStr.includes('laptop') || deviceStr.includes('notebook')) {
                        category = 'Laptop';
                    } else if (deviceStr.includes('desktop') || deviceStr.includes('workstation')) {
                        category = 'Desktop/Workstation';
                    } else if (deviceStr.includes('tablet')) {
                        category = 'Windows Tablet';
                    } else {
                        category = 'Windows Device';
                    }
                }
                
                if (index < 3) console.log(`Windows Device ${index} category:`, category, 'from device:', device);
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });

            console.log('Windows category counts:', categoryCounts);

            // Sort by count (descending)
            const sortedCategories = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);

            sortedCategories.forEach(([category, count]) => {
                const row = tbody.insertRow();
                
                // Category cell with improved formatting
                const categoryCell = row.insertCell(0);
                categoryCell.textContent = category;
                
                // Add visual indicators for special categories
                if (category.includes('(unassigned)') || category.includes('(blank)')) {
                    categoryCell.style.color = '#dc3545';
                    categoryCell.style.fontStyle = 'italic';
                }
                
                // Count cell
                const countCell = row.insertCell(1);
                countCell.textContent = count;
                countCell.style.fontWeight = 'bold';
            });

            // Update Windows compliance with three-way split: Compliant, Unknown (ConfigMgr), Non-Compliant
            if (foundColumns.includes('complianceStateKey')) {
                // Compliant: has "compliant" but NOT ConfigMgr terms
                const compliant = windowsDevices.filter(d => {
                    if (!d.complianceStateKey) return false;
                    const complianceStr = d.complianceStateKey.toString().toLowerCase().trim();
                    return complianceStr.includes('compliant') && 
                           !complianceStr.includes('configmgr') && 
                           !complianceStr.includes('config mgr') &&
                           !complianceStr.includes('see configmgr') &&
                           !complianceStr.includes('sccm') &&
                           !complianceStr.includes('configuration manager');
                }).length;
                
                // Unknown (ConfigMgr): has ConfigMgr terms
                const configMgr = windowsDevices.filter(d => {
                    if (!d.complianceStateKey) return false;
                    const complianceStr = d.complianceStateKey.toString().toLowerCase().trim();
                    return complianceStr.includes('configmgr') || 
                           complianceStr.includes('config mgr') ||
                           complianceStr.includes('see configmgr') ||
                           complianceStr.includes('sccm') ||
                           complianceStr.includes('configuration manager');
                }).length;
                
                // Non-Compliant: everything else
                const nonCompliant = windowsDevices.length - compliant - configMgr;
                
                // Compliance percentage is based only on truly compliant devices
                const compliancePercent = windowsDevices.length > 0 ? (compliant / windowsDevices.length) * 100 : 0;
                
                document.getElementById('windowsCompliantCount').textContent = compliant;
                document.getElementById('windowsConfigMgrCount').textContent = configMgr;
                document.getElementById('windowsNonCompliantCount').textContent = nonCompliant;
                document.getElementById('windowsComplianceFill').style.width = `${compliancePercent}%`;
                document.getElementById('windowsCompliancePercent').textContent = `${compliancePercent.toFixed(1)}%`;
                
                console.log(`Windows compliance breakdown - Compliant: ${compliant}, Unknown (ConfigMgr): ${configMgr}, Non-Compliant: ${nonCompliant}`);
            }
        }

        function populateLifecycleTable(iosDevices) {
            const lifecycleTable = document.getElementById('lifecycleTable');
            if (!lifecycleTable) return;
            
            const tbody = lifecycleTable.getElementsByTagName('tbody')[0];
            if (!tbody) return;
            
            tbody.innerHTML = '';

            // Count devices by model
            const modelCounts = {};
            iosDevices.forEach(device => {
                const model = device.model || 'Unknown Model';
                modelCounts[model] = (modelCounts[model] || 0) + 1;
            });

            // Sort by count (descending) and limit to top models
            const sortedModels = Object.entries(modelCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10); // Show top 10 models

            sortedModels.forEach(([model, count]) => {
                const lifecycle = iosLifecycle[model];
                const deviceStatus = getDeviceStatus(model);
                
                const row = tbody.insertRow();
                row.insertCell(0).textContent = model;
                row.insertCell(1).textContent = count;
                row.insertCell(2).textContent = lifecycle ? lifecycle.endOfLife : 'Unknown';
                
                const statusCell = row.insertCell(3);
                const statusSpan = document.createElement('span');
                statusSpan.textContent = deviceStatus.status;
                
                if (deviceStatus.class === 'eol-good') {
                    statusSpan.className = 'status-supported';
                } else if (deviceStatus.class === 'eol-warning') {
                    statusSpan.className = 'status-security';
                } else {
                    statusSpan.className = 'status-ended';
                }
                
                statusCell.appendChild(statusSpan);
            });
        }

        function exportToPDF() {
            const { jsPDF } = window.jspdf;
            
            // Hide action buttons before capture
            const actionButtons = document.querySelector('.actions-bar');
            const originalDisplay = actionButtons.style.display;
            actionButtons.style.display = 'none';
            
            // Get the report container element
            const element = document.getElementById('reportContainer');
            
            html2canvas(element, {
                scale: 0.7, // Reduce scale to fit better with header/footer
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#ffffff'
            }).then(canvas => {
                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();
                const imgWidth = canvas.width;
                const imgHeight = canvas.height;
                
                // Professional TMH Header
                pdf.setFillColor(0, 61, 92); // TMH Blue
                pdf.rect(0, 0, pdfWidth, 20, 'F');
                pdf.setTextColor(255, 255, 255);
                pdf.setFontSize(16);
                pdf.setFont('helvetica', 'bold');
                pdf.text('TMH DEVICE INVENTORY REPORT', pdfWidth / 2, 12, { align: 'center' });
                
                // Calculate dimensions to fit with header/footer margins
                const topMargin = 25;
                const bottomMargin = 25;
                const sideMargin = 10;
                const availableWidth = pdfWidth - (2 * sideMargin);
                const availableHeight = pdfHeight - topMargin - bottomMargin;
                const ratio = Math.min(availableWidth / imgWidth, availableHeight / imgHeight);
                
                const finalWidth = imgWidth * ratio;
                const finalHeight = imgHeight * ratio;
                const imgX = (pdfWidth - finalWidth) / 2;
                const imgY = topMargin;
                
                pdf.addImage(imgData, 'PNG', imgX, imgY, finalWidth, finalHeight);
                
                // Professional Footer with generation timestamp
                const currentDate = new Date();
                const dateString = currentDate.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                pdf.setFillColor(0, 61, 92); // TMH Blue
                pdf.rect(0, pdfHeight - 15, pdfWidth, 15, 'F');
                pdf.setTextColor(255, 255, 255);
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'normal');
                pdf.text('Tallahassee Memorial Hospital', 10, pdfHeight - 8);
                pdf.text(`Generated: ${dateString}`, pdfWidth - 10, pdfHeight - 8, { align: 'right' });
                pdf.text('IT Asset Management', pdfWidth / 2, pdfHeight - 8, { align: 'center' });
                
                pdf.save('tmh-device-inventory-report.pdf');
                
                // Restore action buttons
                actionButtons.style.display = originalDisplay;
            }).catch(error => {
                console.error('Error generating PDF:', error);
                // Restore action buttons even if there's an error
                actionButtons.style.display = originalDisplay;
            });
        }

        /* exportToHTML function removed as Export to HTML button was removed */

        // iOS device lifecycle data
        const iosLifecycle = {
            'iPhone 15 Pro Max': { releaseYear: 2023, endOfLife: 2030 },
            'iPhone 15 Pro': { releaseYear: 2023, endOfLife: 2030 },
            'iPhone 15 Plus': { releaseYear: 2023, endOfLife: 2030 },
            'iPhone 15': { releaseYear: 2023, endOfLife: 2030 },
            'iPhone 14 Pro Max': { releaseYear: 2022, endOfLife: 2029 },
            'iPhone 14 Pro': { releaseYear: 2022, endOfLife: 2029 },
            'iPhone 14 Plus': { releaseYear: 2022, endOfLife: 2029 },
            'iPhone 14': { releaseYear: 2022, endOfLife: 2029 },
            'iPhone 13 Pro Max': { releaseYear: 2021, endOfLife: 2028 },
            'iPhone 13 Pro': { releaseYear: 2021, endOfLife: 2028 },
            'iPhone 13 mini': { releaseYear: 2021, endOfLife: 2028 },
            'iPhone 13': { releaseYear: 2021, endOfLife: 2028 },
            'iPhone 12 Pro Max': { releaseYear: 2020, endOfLife: 2027 },
            'iPhone 12 Pro': { releaseYear: 2020, endOfLife: 2027 },
            'iPhone 12 mini': { releaseYear: 2020, endOfLife: 2027 },
            'iPhone 12': { releaseYear: 2020, endOfLife: 2027 },
            'iPhone SE (3rd generation)': { releaseYear: 2022, endOfLife: 2029 },
            'iPhone 11 Pro Max': { releaseYear: 2019, endOfLife: 2026 },
            'iPhone 11 Pro': { releaseYear: 2019, endOfLife: 2026 },
            'iPhone 11': { releaseYear: 2019, endOfLife: 2026 },
            'iPhone XS Max': { releaseYear: 2018, endOfLife: 2025 },
            'iPhone XS': { releaseYear: 2018, endOfLife: 2025 },
            'iPhone XR': { releaseYear: 2018, endOfLife: 2025 },
            'iPhone X': { releaseYear: 2017, endOfLife: 2024 },
            'iPhone 8 Plus': { releaseYear: 2017, endOfLife: 2024 },
            'iPhone 8': { releaseYear: 2017, endOfLife: 2024 },
            'iPhone 7 Plus': { releaseYear: 2016, endOfLife: 2023 },
            'iPhone 7': { releaseYear: 2016, endOfLife: 2023 },
            'iPhone SE (2nd generation)': { releaseYear: 2020, endOfLife: 2027 },
            'iPhone 6s Plus': { releaseYear: 2015, endOfLife: 2022 },
            'iPhone 6s': { releaseYear: 2015, endOfLife: 2022 },
            'iPhone 6 Plus': { releaseYear: 2014, endOfLife: 2021 },
            'iPhone 6': { releaseYear: 2014, endOfLife: 2021 },
            'iPad Pro 12.9-inch (6th generation)': { releaseYear: 2022, endOfLife: 2029 },
            'iPad Pro 11-inch (4th generation)': { releaseYear: 2022, endOfLife: 2029 },
            'iPad Air (5th generation)': { releaseYear: 2022, endOfLife: 2029 },
            'iPad (10th generation)': { releaseYear: 2022, endOfLife: 2029 },
            'iPad mini (6th generation)': { releaseYear: 2021, endOfLife: 2028 },
            'iPad Pro 12.9-inch (5th generation)': { releaseYear: 2021, endOfLife: 2028 },
            'iPad Pro 11-inch (3rd generation)': { releaseYear: 2021, endOfLife: 2028 },
            'iPad Air (4th generation)': { releaseYear: 2020, endOfLife: 2027 },
            'iPad (9th generation)': { releaseYear: 2021, endOfLife: 2028 },
            'iPad (8th generation)': { releaseYear: 2020, endOfLife: 2027 }
        };

        let globalDevicesData = [];

        function clearReportData() {
            // Clear summary cards
            document.getElementById('iosTotal').textContent = '0';
            document.getElementById('androidTotal').textContent = '0';
            document.getElementById('totalDevices').textContent = '0';
            
            // Clear compliance bars
            const complianceElements = [
                { fill: 'iosCompliant', text: 'iosComplianceText' },
                { fill: 'androidCompliant', text: 'androidComplianceText' }
            ];
            
            complianceElements.forEach(({ fill, text }) => {
                const fillElement = document.getElementById(fill);
                const textElement = document.getElementById(text);
                if (fillElement) fillElement.style.width = '0%';
                if (textElement) textElement.textContent = '0%';
            });
            
            // Clear tables
            const tables = ['osTable', 'iosTable', 'androidTable', 'lifecycleTable'];
            tables.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (table) {
                    const tbody = table.getElementsByTagName('tbody')[0];
                    if (tbody) tbody.innerHTML = '';
                }
            });
            
            // Clear compliance text elements
            const complianceTextElements = [
                'iosCompliantCount', 'iosNonCompliantCount', 'iosCompliancePercent',
                'androidCompliantCount', 'androidNonCompliantCount', 'androidCompliancePercent'
            ];
            complianceTextElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) element.textContent = '0';
            });
            
            // Clear compliance bars
            const complianceFills = ['iosComplianceFill', 'androidComplianceFill'];
            complianceFills.forEach(fillId => {
                const fill = document.getElementById(fillId);
                if (fill) fill.style.width = '0%';
            });
            
            // Clear special counts
            const specialElements = ['configMgrCount', 'unassignedCount'];
            specialElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) element.textContent = '0';
            });
            
            // Hide Windows special section by default
            const windowsSpecialSection = document.getElementById('windowsSpecialSection');
            if (windowsSpecialSection) {
                windowsSpecialSection.style.display = 'none';
            }
            
            // Clear urgent items
            const urgentItemsContainer = document.getElementById('urgentItems');
            if (urgentItemsContainer) {
                urgentItemsContainer.innerHTML = '';
            }
            
            // Reset urgent indicator
            const urgentIndicator = document.getElementById('urgentIndicator');
            if (urgentIndicator) {
                urgentIndicator.style.display = 'none';
                urgentIndicator.classList.add('no-urgent');
                const countElement = urgentIndicator.querySelector('.urgent-count');
                if (countElement) {
                    countElement.textContent = '0';
                }
            }
            
            // Show compliance section (in case it was hidden)
            const complianceSection = document.querySelector('.compliance-section');
            if (complianceSection) {
                complianceSection.style.display = 'block';
            }
            
            // Show data sections (in case they were hidden)
            const dataSections = document.querySelectorAll('.data-section');
            dataSections.forEach(section => {
                section.style.display = 'block';
            });
        }

        function getDeviceStatus(model, currentYear = new Date().getFullYear()) {
            const lifecycle = iosLifecycle[model];
            if (!lifecycle) return { status: 'Unknown', class: 'eol-warning' };
            
            const yearsUntilEOL = lifecycle.endOfLife - currentYear;
            
            if (yearsUntilEOL <= 0) {
                return { status: 'End of Life', class: 'eol-critical' };
            } else if (yearsUntilEOL <= 2) {
                return { status: `EOL in ${yearsUntilEOL} year${yearsUntilEOL > 1 ? 's' : ''}`, class: 'eol-warning' };
            } else {
                return { status: `Supported until ${lifecycle.endOfLife}`, class: 'eol-good' };
            }
        }

        /* Modal-related functions removed to clean up layout - functionality can be re-added if needed */

        // Update the urgent indicator in the header
        function updateUrgentIndicator(urgentItems) {
            const urgentIndicator = document.getElementById('urgentIndicator');
            if (!urgentIndicator) return;
            
            // Calculate total urgent items with priority weighting
            const highPriorityItems = urgentItems.filter(item => item.severity === 'high');
            const mediumPriorityItems = urgentItems.filter(item => item.severity === 'medium');
            const lowPriorityItems = urgentItems.filter(item => item.severity === 'low');
            
            const totalCount = urgentItems.reduce((sum, item) => sum + item.count, 0);
            
            // Update the count display
            const countElement = urgentIndicator.querySelector('.urgent-count');
            if (countElement) {
                countElement.textContent = totalCount;
            }
            
            // Update the indicator appearance based on urgency
            urgentIndicator.classList.remove('no-urgent');
            
            if (highPriorityItems.length > 0) {
                urgentIndicator.style.background = 'rgba(220, 53, 69, 0.9)'; // Red for high priority
                urgentIndicator.title = `${highPriorityItems.length} critical issues requiring immediate attention`;
            } else if (mediumPriorityItems.length > 0) {
                urgentIndicator.style.background = 'rgba(255, 193, 7, 0.9)'; // Yellow for medium priority
                urgentIndicator.title = `${mediumPriorityItems.length} warning issues requiring attention`;
            } else if (lowPriorityItems.length > 0) {
                urgentIndicator.style.background = 'rgba(108, 117, 125, 0.9)'; // Gray for low priority
                urgentIndicator.title = `${lowPriorityItems.length} minor issues`;
            } else {
                urgentIndicator.classList.add('no-urgent');
                urgentIndicator.style.background = 'rgba(40, 167, 69, 0.9)'; // Green for no issues
                urgentIndicator.title = 'No urgent items';
            }
            
            // Show the indicator
            urgentIndicator.style.display = 'block';
        }

        // Scroll to urgent items section
        function scrollToUrgentItems() {
            const urgentSection = document.querySelector('.urgent-items');
            if (urgentSection) {
                urgentSection.scrollIntoView({ 
                    behavior: 'smooth',
                    block: 'start'
                });
                
                // Add a brief highlight effect
                urgentSection.style.background = '#fff3cd';
                setTimeout(() => {
                    urgentSection.style.background = '#fff';
                }, 2000);
            }
        }

        // Historical Inventory Tracking Functions
        function saveHistoricalData() {
            const months = ['march2025', 'april2025', 'may2025', 'june2025'];
            const platforms = ['ios', 'android'];
            
            const historicalData = {
                ios: {},
                android: {}
            };
            let hasData = false;
            
            // Save platform-specific data
            platforms.forEach(platform => {
                months.forEach(month => {
                    const elementId = `${platform}_${month}`;
                    const element = document.getElementById(elementId);
                    if (element && element.value && element.value.trim() !== '') {
                        historicalData[platform][month] = parseInt(element.value);
                        hasData = true;
                    }
                });
            });
            
            if (!hasData) {
                alert('Please enter at least one month of platform trend data before saving.');
                return;
            }
            
            localStorage.setItem('tmhPlatformTrends', JSON.stringify(historicalData));
            updateInventoryTrends();
            updateMonthlyComparison();
            updateCFOTrendTables();
            
            // Show success message
            const saveButton = event.target;
            const originalText = saveButton.textContent;
            saveButton.textContent = '✅ Saved!';
            saveButton.style.background = '#28a745';
            setTimeout(() => {
                saveButton.textContent = originalText;
                saveButton.style.background = '#003d5c';
            }, 2000);
        }

        function loadHistoricalData() {
            const saved = localStorage.getItem('tmhPlatformTrends');
            if (!saved) {
                alert('No platform trend data found. Data is pre-loaded - try clicking "💾 Save Trends" first.');
                return;
            }
            
            try {
                const historicalData = JSON.parse(saved);
                const months = ['march2025', 'april2025', 'may2025', 'june2025'];
                const platforms = ['ios', 'android'];
                
                // Load platform-specific data
                platforms.forEach(platform => {
                    if (historicalData[platform]) {
                        months.forEach(month => {
                            const elementId = `${platform}_${month}`;
                            const element = document.getElementById(elementId);
                            if (element && historicalData[platform][month] !== undefined) {
                                element.value = historicalData[platform][month];
                            }
                        });
                    }
                });
                
                updateInventoryTrends();
                updateMonthlyComparison();
                updateCFOTrendTables();
                
                // Show success message
                const loadButton = event.target;
                const originalText = loadButton.textContent;
                loadButton.textContent = '✅ Loaded!';
                setTimeout(() => {
                    loadButton.textContent = originalText;
                }, 2000);
                
            } catch (error) {
                alert('Error loading platform trend data: ' + error.message);
            }
        }

        function updateInventoryTrends() {
            const months = [
                { id: 'march2025', label: 'Mar 2025' },
                { id: 'april2025', label: 'Apr 2025' },
                { id: 'may2025', label: 'May 2025' },
                { id: 'june2025', label: 'Jun 2025' }
            ];
            const platforms = ['ios', 'android'];
            
            const trendsContainer = document.getElementById('inventoryTrends');
            const platformData = {};
            let maxValue = 0;
            
            // Collect data for each platform
            platforms.forEach(platform => {
                platformData[platform] = [];
                months.forEach(month => {
                    const elementId = `${platform}_${month.id}`;
                    const element = document.getElementById(elementId);
                    if (element && element.value && element.value.trim() !== '') {
                        const numValue = parseInt(element.value);
                        platformData[platform].push({ label: month.label, value: numValue });
                        maxValue = Math.max(maxValue, numValue);
                    }
                });
                
                // Add current month data if available
                const currentElement = document.getElementById(`${platform}_current`);
                if (currentElement && currentElement.value && currentElement.value.trim() !== '') {
                    const numValue = parseInt(currentElement.value);
                    platformData[platform].push({ label: 'Current', value: numValue });
                    maxValue = Math.max(maxValue, numValue);
                }
            });
            
            if (Object.values(platformData).every(data => data.length === 0)) {
                trendsContainer.innerHTML = '<p style="text-align: center; color: #6c757d; margin-top: 3rem; font-style: italic;">Platform trend data is pre-loaded. Click "💾 Save Trends" to see charts.</p>';
                return;
            }
            
            let chartHTML = '<h5 style="margin-bottom: 1rem; color: #003d5c;">Platform Trend Analysis</h5>';
            
            // Create side-by-side charts for iOS and Android
            chartHTML += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">';
            
            // iOS Chart
            if (platformData.ios.length > 0) {
                chartHTML += '<div style="background: #f0f7ff; padding: 0.8rem; border-radius: 6px; border-left: 4px solid #0056b3;">';
                chartHTML += '<h6 style="color: #0056b3; margin-bottom: 0.8rem; font-size: 0.8rem;">🍎 iOS Devices</h6>';
                chartHTML += '<div style="display: flex; align-items: end; height: 100px; gap: 4px;">';
                
                platformData.ios.forEach((item, index) => {
                    const height = (item.value / maxValue) * 100;
                    const isCurrentMonth = item.label === 'Current';
                    const barColor = isCurrentMonth ? '#28a745' : '#0056b3';
                    
                    chartHTML += `
                        <div style="flex: 1; display: flex; flex-direction: column; align-items: center;">
                            <div style="background: ${barColor}; width: 100%; height: ${height}%; min-height: 5px; border-radius: 3px 3px 0 0; margin-bottom: 3px; display: flex; align-items: end; justify-content: center; color: white; font-size: 0.6rem; font-weight: bold; padding: 1px;">
                                ${item.value}
                            </div>
                            <div style="font-size: 0.5rem; color: #6c757d; text-align: center; writing-mode: vertical-rl; text-orientation: mixed;">
                                ${item.label}
                            </div>
                        </div>
                    `;
                });
                
                chartHTML += '</div>';
                
                // iOS trend summary
                if (platformData.ios.length > 1) {
                    const firstValue = platformData.ios[0].value;
                    const lastValue = platformData.ios[platformData.ios.length - 1].value;
                    const change = lastValue - firstValue;
                    const changePercent = ((change / firstValue) * 100).toFixed(1);
                    const changeColor = change > 0 ? '#28a745' : change < 0 ? '#dc3545' : '#6c757d';
                    const changeIcon = change > 0 ? '📈' : change < 0 ? '📉' : '➡️';
                    
                    chartHTML += `
                        <div style="margin-top: 0.5rem; font-size: 0.7rem; color: ${changeColor}; font-weight: bold;">
                            ${changeIcon} ${change > 0 ? '+' : ''}${change} (${changePercent}%)
                        </div>
                    `;
                }
                
                chartHTML += '</div>';
            }
            
            // Android Chart
            if (platformData.android.length > 0) {
                chartHTML += '<div style="background: #f0fff4; padding: 0.8rem; border-radius: 6px; border-left: 4px solid #28a745;">';
                chartHTML += '<h6 style="color: #28a745; margin-bottom: 0.8rem; font-size: 0.8rem;">🤖 Android Devices</h6>';
                chartHTML += '<div style="display: flex; align-items: end; height: 100px; gap: 4px;">';
                
                platformData.android.forEach((item, index) => {
                    const height = (item.value / maxValue) * 100;
                    const isCurrentMonth = item.label === 'Current';
                    const barColor = isCurrentMonth ? '#0056b3' : '#28a745';
                    
                    chartHTML += `
                        <div style="flex: 1; display: flex; flex-direction: column; align-items: center;">
                            <div style="background: ${barColor}; width: 100%; height: ${height}%; min-height: 5px; border-radius: 3px 3px 0 0; margin-bottom: 3px; display: flex; align-items: end; justify-content: center; color: white; font-size: 0.6rem; font-weight: bold; padding: 1px;">
                                ${item.value}
                            </div>
                            <div style="font-size: 0.5rem; color: #6c757d; text-align: center; writing-mode: vertical-rl; text-orientation: mixed;">
                                ${item.label}
                            </div>
                        </div>
                    `;
                });
                
                chartHTML += '</div>';
                
                // Android trend summary
                if (platformData.android.length > 1) {
                    const firstValue = platformData.android[0].value;
                    const lastValue = platformData.android[platformData.android.length - 1].value;
                    const change = lastValue - firstValue;
                    const changePercent = ((change / firstValue) * 100).toFixed(1);
                    const changeColor = change > 0 ? '#28a745' : change < 0 ? '#dc3545' : '#6c757d';
                    const changeIcon = change > 0 ? '📈' : change < 0 ? '📉' : '➡️';
                    
                    chartHTML += `
                        <div style="margin-top: 0.5rem; font-size: 0.7rem; color: ${changeColor}; font-weight: bold;">
                            ${changeIcon} ${change > 0 ? '+' : ''}${change} (${changePercent}%)
                        </div>
                    `;
                }
                
                chartHTML += '</div>';
            }
            
            chartHTML += '</div>';
            
            // Overall comparison
            if (platformData.ios.length > 0 && platformData.android.length > 0) {
                chartHTML += `
                    <div style="padding: 0.8rem; background: #f8fafb; border-radius: 4px; border-left: 4px solid #003d5c;">
                        <div style="font-size: 0.8rem; color: #003d5c; font-weight: 600; margin-bottom: 0.5rem;">Platform Comparison:</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; font-size: 0.7rem;">
                            <div>iOS: ${platformData.ios[platformData.ios.length - 1]?.value || 'N/A'} devices</div>
                            <div>Android: ${platformData.android[platformData.android.length - 1]?.value || 'N/A'} devices</div>
                        </div>
                    </div>
                `;
            }
            
            trendsContainer.innerHTML = chartHTML;
        }

        function updateCFOTrendTables() {
            const months = [
                { id: 'march2025', label: 'Mar' },
                { id: 'april2025', label: 'Apr' },
                { id: 'may2025', label: 'May' },
                { id: 'june2025', label: 'Jun' }
            ];
            const platforms = ['ios', 'android'];
            
            platforms.forEach(platform => {
                const tableId = `${platform}TrendTable`;
                const tbody = document.querySelector(`#${tableId} tbody`);
                if (!tbody) return;
                
                let tableHTML = '';
                let previousValue = null;
                
                months.forEach(month => {
                    const elementId = `${platform}_${month.id}`;
                    const element = document.getElementById(elementId);
                    
                    if (element && element.value && element.value.trim() !== '') {
                        const currentValue = parseInt(element.value);
                        let changeHTML = '<span class="trend-indicator trend-neutral">—</span>';
                        
                        if (previousValue !== null) {
                            const change = currentValue - previousValue;
                            if (change > 0) {
                                changeHTML = `<span class="trend-indicator trend-positive">+${change}</span>`;
                            } else if (change < 0) {
                                changeHTML = `<span class="trend-indicator trend-negative">${change}</span>`;
                            } else {
                                changeHTML = '<span class="trend-indicator trend-neutral">0</span>';
                            }
                        }
                        
                        tableHTML += `
                            <tr>
                                <td>${month.label}</td>
                                <td>${currentValue.toLocaleString()}</td>
                                <td>${changeHTML}</td>
                            </tr>
                        `;
                        
                        previousValue = currentValue;
                    }
                });
                
                // Add current month if available
                const currentElement = document.getElementById(`${platform}_current`);
                if (currentElement && currentElement.value && currentElement.value.trim() !== '') {
                    const currentValue = parseInt(currentElement.value);
                    let changeHTML = '<span class="trend-indicator trend-neutral">—</span>';
                    
                    if (previousValue !== null) {
                        const change = currentValue - previousValue;
                        if (change > 0) {
                            changeHTML = `<span class="trend-indicator trend-positive">+${change}</span>`;
                        } else if (change < 0) {
                            changeHTML = `<span class="trend-indicator trend-negative">${change}</span>`;
                        } else {
                            changeHTML = '<span class="trend-indicator trend-neutral">0</span>';
                        }
                    }
                    
                    tableHTML += `
                        <tr style="background: ${platform === 'ios' ? '#e3f2fd' : '#e8f5e8'}; font-weight: bold;">
                            <td>Current</td>
                            <td>${currentValue.toLocaleString()}</td>
                            <td>${changeHTML}</td>
                        </tr>
                    `;
                }
                
                tbody.innerHTML = tableHTML;
            });
        }

        function updateMonthlyComparison() {
            const months = [
                { id: 'march2025', label: 'March 2025' },
                { id: 'april2025', label: 'April 2025' },
                { id: 'may2025', label: 'May 2025' },
                { id: 'june2025', label: 'June 2025' }
            ];
            const platforms = ['ios', 'android'];
            
            const comparisonContainer = document.getElementById('monthlyComparison');
            
            let tableHTML = `
                <h4 style="color: #003d5c; margin-bottom: 1rem; font-size: 0.9rem;">Platform Trend Comparison</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
            `;
            
            // Create separate tables for iOS and Android
            platforms.forEach(platform => {
                const platformData = [];
                const platformName = platform.toUpperCase();
                const platformColor = platform === 'ios' ? '#0056b3' : '#28a745';
                
                // Collect platform data
                months.forEach(month => {
                    const elementId = `${platform}_${month.id}`;
                    const element = document.getElementById(elementId);
                    if (element && element.value && element.value.trim() !== '') {
                        platformData.push({ 
                            label: month.label, 
                            value: parseInt(element.value), 
                            id: elementId 
                        });
                    }
                });
                
                // Add current month if available
                const currentElement = document.getElementById(`${platform}_current`);
                if (currentElement && currentElement.value && currentElement.value.trim() !== '') {
                    platformData.push({ 
                        label: 'Current Month', 
                        value: parseInt(currentElement.value), 
                        id: `${platform}_current` 
                    });
                }
                
                if (platformData.length > 0) {
                    tableHTML += `
                        <div>
                            <h5 style="color: ${platformColor}; margin-bottom: 0.8rem; font-size: 0.8rem;">${platformName} Trends</h5>
                            <table class="data-table" style="font-size: 0.7rem;">
                                <thead>
                                    <tr>
                                        <th>Month</th>
                                        <th>Count</th>
                                        <th>Change</th>
                                        <th>%</th>
                                        <th>Trend</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;
                    
                    platformData.forEach((item, index) => {
                        let changeText = '-';
                        let changePercent = '-';
                        let trendIcon = '-';
                        let changeColor = '#6c757d';
                        
                        if (index > 0) {
                            const prevValue = platformData[index - 1].value;
                            const change = item.value - prevValue;
                            const percent = ((change / prevValue) * 100).toFixed(1);
                            
                            changeText = change > 0 ? `+${change}` : `${change}`;
                            changePercent = change > 0 ? `+${percent}%` : `${percent}%`;
                            
                            if (change > 0) {
                                changeColor = '#28a745';
                                trendIcon = '↑';
                            } else if (change < 0) {
                                changeColor = '#dc3545';
                                trendIcon = '↓';
                            } else {
                                changeColor = '#6c757d';
                                trendIcon = '→';
                            }
                        }
                        
                        const isCurrentMonth = item.label === 'Current Month';
                        const rowStyle = isCurrentMonth ? `background: ${platform === 'ios' ? '#e3f2fd' : '#e8f5e8'}; font-weight: bold;` : '';
                        
                        tableHTML += `
                            <tr style="${rowStyle}">
                                <td>${item.label.replace('2024', '').trim()}${isCurrentMonth ? ' *' : ''}</td>
                                <td style="font-weight: bold;">${item.value.toLocaleString()}</td>
                                <td style="color: ${changeColor}; font-weight: bold;">${changeText}</td>
                                <td style="color: ${changeColor}; font-weight: bold;">${changePercent}</td>
                                <td style="color: ${changeColor};">${trendIcon}</td>
                            </tr>
                        `;
                    });
                    
                    tableHTML += `
                            </tbody>
                        </table>
                    `;
                    
                    // Add platform summary
                    if (platformData.length > 1) {
                        const firstValue = platformData[0].value;
                        const lastValue = platformData[platformData.length - 1].value;
                        const totalChange = lastValue - firstValue;
                        const totalChangePercent = ((totalChange / firstValue) * 100).toFixed(1);
                        const changeColor = totalChange > 0 ? '#28a745' : totalChange < 0 ? '#dc3545' : '#6c757d';
                        
                        tableHTML += `
                            <div style="margin-top: 0.5rem; padding: 0.5rem; background: ${platform === 'ios' ? '#f0f7ff' : '#f0fff4'}; border-radius: 4px; font-size: 0.7rem;">
                                <strong>Period Change:</strong> 
                                <span style="color: ${changeColor}; font-weight: bold;">
                                    ${totalChange > 0 ? '+' : ''}${totalChange} (${totalChangePercent}%)
                                </span>
                            </div>
                        `;
                    }
                    
                    tableHTML += '</div>';
                }
            });
            
            tableHTML += '</div>';
            
            comparisonContainer.innerHTML = tableHTML;
        }

        function exportHistoricalData() {
            const months = [
                { id: 'march2025', label: 'March 2025' },
                { id: 'april2025', label: 'April 2025' },
                { id: 'may2025', label: 'May 2025' },
                { id: 'june2025', label: 'June 2025' }
            ];
            const platforms = ['ios', 'android'];
            
            // Generate CSV content with platform-specific data
            let csvContent = 'Month,iOS Count,iOS Change,iOS %,Android Count,Android Change,Android %\n';
            
            const platformData = {};
            platforms.forEach(platform => {
                platformData[platform] = [];
                months.forEach(month => {
                    const elementId = `${platform}_${month.id}`;
                    const element = document.getElementById(elementId);
                    if (element && element.value && element.value.trim() !== '') {
                        platformData[platform].push({
                            label: month.label,
                            value: parseInt(element.value)
                        });
                    }
                });
                
                // Add current month
                const currentElement = document.getElementById(`${platform}_current`);
                if (currentElement && currentElement.value && currentElement.value.trim() !== '') {
                    platformData[platform].push({
                        label: 'Current Month',
                        value: parseInt(currentElement.value)
                    });
                }
            });
            
            // Create rows based on maximum data length
            const maxLength = Math.max(platformData.ios.length, platformData.android.length);
            
            for (let i = 0; i < maxLength; i++) {
                const iosData = platformData.ios[i];
                const androidData = platformData.android[i];
                
                let row = '';
                
                // Month label (use iOS data first, fall back to Android)
                const monthLabel = iosData?.label || androidData?.label || '';
                row += `"${monthLabel}",`;
                
                // iOS data
                if (iosData) {
                    const iosChange = i > 0 && platformData.ios[i-1] ? 
                        iosData.value - platformData.ios[i-1].value : '';
                    const iosPercent = i > 0 && platformData.ios[i-1] && platformData.ios[i-1].value > 0 ? 
                        ((iosChange / platformData.ios[i-1].value) * 100).toFixed(1) + '%' : '';
                    
                    row += `${iosData.value},"${iosChange > 0 ? '+' + iosChange : iosChange}","${iosPercent}",`;
                } else {
                    row += ',,';
                }
                
                // Android data
                if (androidData) {
                    const androidChange = i > 0 && platformData.android[i-1] ? 
                        androidData.value - platformData.android[i-1].value : '';
                    const androidPercent = i > 0 && platformData.android[i-1] && platformData.android[i-1].value > 0 ? 
                        ((androidChange / platformData.android[i-1].value) * 100).toFixed(1) + '%' : '';
                    
                    row += `${androidData.value},"${androidChange > 0 ? '+' + androidChange : androidChange}","${androidPercent}"`;
                } else {
                    row += ',,';
                }
                
                csvContent += row + '\n';
            }
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'tmh-platform-trends.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Show success message
            const exportButton = event.target;
            const originalText = exportButton.textContent;
            exportButton.textContent = 'Exported!';
            setTimeout(() => {
                exportButton.textContent = originalText;
            }, 2000);
        }

        function clearHistoricalData() {
            if (!confirm('Are you sure you want to clear all platform trend data? This action cannot be undone.')) {
                return;
            }
            
            const months = ['march2025', 'april2025', 'may2025', 'june2025'];
            const platforms = ['ios', 'android'];
            
            // Clear all platform input fields
            platforms.forEach(platform => {
                months.forEach(month => {
                    const input = document.getElementById(`${platform}_${month}`);
                    if (input) {
                        input.value = '';
                    }
                });
            });
            
            // Clear localStorage
            localStorage.removeItem('tmhPlatformTrends');
            
            // Update displays
            updateInventoryTrends();
            updateMonthlyComparison();
            updateCFOTrendTables();
            
            // Show success message
            const clearButton = event.target;
            const originalText = clearButton.textContent;
            clearButton.textContent = 'Cleared!';
            setTimeout(() => {
                clearButton.textContent = originalText;
            }, 2000);
        }

        // Auto-load platform trend data on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Try to load saved platform trend data
            const saved = localStorage.getItem('tmhPlatformTrends');
            if (saved) {
                try {
                    const historicalData = JSON.parse(saved);
                    const months = ['march2025', 'april2025', 'may2025', 'june2025'];
                    const platforms = ['ios', 'android'];
                    
                    platforms.forEach(platform => {
                        if (historicalData[platform]) {
                            months.forEach(month => {
                                const elementId = `${platform}_${month}`;
                                const element = document.getElementById(elementId);
                                if (element && historicalData[platform][month] !== undefined) {
                                    element.value = historicalData[platform][month];
                                }
                            });
                        }
                    });
                    
                    updateInventoryTrends();
                    updateMonthlyComparison();
                    updateCFOTrendTables();
                } catch (error) {
                    console.log('Could not load platform trend data:', error);
                }
            }
            
            // Auto-save the pre-loaded data and populate CFO tables
            setTimeout(() => {
                saveHistoricalData();
                updateCFOTrendTables();
            }, 1000);
            
            // Add event listeners to platform trend inputs for real-time updates
            const months = ['march2025', 'april2025', 'may2025', 'june2025'];
            const platforms = ['ios', 'android'];
            
            platforms.forEach(platform => {
                months.forEach(month => {
                    const elementId = `${platform}_${month}`;
                    const element = document.getElementById(elementId);
                    if (element && historicalData[platform] && historicalData[platform][month] !== undefined) {
                        element.value = historicalData[platform][month];
                    }
                });
                
                // Add current month if available
                const currentElement = document.getElementById(`${platform}_current`);
                if (currentElement && historicalData[platform] && historicalData[platform].current !== undefined) {
                    currentElement.value = historicalData[platform].current;
                }
            });
        });

        // Debug function to log category information for troubleshooting
        function logCategoryDebugInfo(devices, foundColumns) {
            if (!foundColumns.includes('deviceCategoryKey')) {
                console.log('No deviceCategoryKey column found - using fallback categorization');
                return;
            }
            
            console.log('\nCATEGORY DEBUG INFO:');
            
            // Get all unique categories
            const allCategories = new Set();
            const androidDevices = [];
            const iosDevices = [];
            const windowsDevices = [];
            
            devices.forEach(device => {
                if (device.deviceCategoryKey) {
                    allCategories.add(device.deviceCategoryKey.toString().trim());
                }
                
                // Sort by OS for detailed breakdown
                const deviceStr = JSON.stringify(device).toLowerCase();
                if (deviceStr.includes('android')) {
                    androidDevices.push(device);
                } else if (deviceStr.includes('ios')) {
                    iosDevices.push(device);
                } else if (deviceStr.includes('windows')) {
                    windowsDevices.push(device);
                }
            });
            
            console.log(`Total devices: ${devices.length}`);
            console.log(`Total unique categories found: ${allCategories.size}`);
            console.log(`Android devices: ${androidDevices.length}`);
            console.log(`iOS devices: ${iosDevices.length}`);
            console.log(`Windows devices: ${windowsDevices.length}`);
            
            // List all unique categories
            console.log('\nAll detected categories:');
            [...allCategories].sort().forEach(cat => {
                console.log(`   • "${cat}"`);
            });
            
            // Check for specific categories the user mentioned
            const targetCategories = ['backstock', 'epic welcome', 'epic-welcome', 'epicwelcome'];
            console.log('\nChecking for specific categories:');
            targetCategories.forEach(target => {
                const found = [...allCategories].filter(cat => 
                    cat.toLowerCase().includes(target.toLowerCase())
                );
                if (found.length > 0) {
                    console.log(`   Found "${target}": ${found.join(', ')}`);
                } else {
                    console.log(`   Not found: "${target}"`);
                }
            });
            
            // Android category breakdown
            if (androidDevices.length > 0) {
                console.log('\nAndroid device categories:');
                const androidCats = {};
                androidDevices.forEach(device => {
                    const cat = device.deviceCategoryKey ? device.deviceCategoryKey.toString().trim() : '(no category)';
                    androidCats[cat] = (androidCats[cat] || 0) + 1;
                });
                Object.entries(androidCats).sort((a, b) => b[1] - a[1]).forEach(([cat, count]) => {
                    console.log(`   • "${cat}": ${count} devices`);
                });
            }
        }

        function autoFillCurrentCounts() {
            // Get current device counts from the summary cards
            const iosCount = parseInt(document.getElementById('iosTotal').textContent) || 0;
            const androidCount = parseInt(document.getElementById('androidTotal').textContent) || 0;
            
            // Auto-fill the current month fields
            const iosCurrent = document.getElementById('ios_current');
            const androidCurrent = document.getElementById('android_current');
            
            if (iosCurrent) {
                iosCurrent.value = iosCount;
            }
            if (androidCurrent) {
                androidCurrent.value = androidCount;
            }
            
            // Update the comparison table
            updateMonthlyComparison();
            
            // Show success message
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Filled!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }

        function clearMonthlyCounts() {
            if (!confirm('Are you sure you want to clear all monthly count data? This action cannot be undone.')) {
                return;
            }
            
            const months = ['march2025', 'april2025', 'may2025', 'june2025'];
            const platforms = ['ios', 'android'];
            
            // Clear all monthly input fields
            platforms.forEach(platform => {
                months.forEach(month => {
                    const input = document.getElementById(`${platform}_${month}`);
                    if (input) {
                        input.value = '';
                    }
                });
                
                // Clear current month field
                const currentInput = document.getElementById(`${platform}_current`);
                if (currentInput) {
                    currentInput.value = '';
                }
            });
            
            // Update the comparison table
            updateMonthlyComparison();
            
            // Show success message
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Cleared!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }

        function debugCategories() {
            if (!window.lastProcessedData || !window.lastFoundColumns) {
                alert('No data has been processed yet. Please upload and process a file first.');
                return;
            }
            
            const data = window.lastProcessedData;
            const foundColumns = window.lastFoundColumns;
            
            console.log('=== CATEGORY DEBUG REPORT ===');
            console.log('Total devices (unfiltered):', data.length);
            console.log('Found columns:', foundColumns);
            console.log('deviceCategoryKey column found:', foundColumns.includes('deviceCategoryKey'));
            
            // Apply the same filtering as the main processing
            // Filter out Windows devices first
            const activeDevices = data.filter(device => {
                const deviceStr = JSON.stringify(device).toLowerCase();
                const osVersion = device.osVersion ? device.osVersion.toString().toLowerCase() : '';
                const operatingSystem = device.operatingSystem ? device.operatingSystem.toString().toLowerCase() : '';
                const model = device.model ? device.model.toString().toLowerCase() : '';
                const manufacturer = device.manufacturer ? device.manufacturer.toString().toLowerCase() : '';
                
                const isWindows = osVersion.includes('windows') || 
                                 operatingSystem.includes('windows') ||
                                 deviceStr.includes('windows') ||
                                 deviceStr.includes('microsoft') ||
                                 manufacturer.includes('microsoft') ||
                                 model.includes('surface') ||
                                 deviceStr.includes('win10') ||
                                 deviceStr.includes('win11');
                
                return !isWindows;
            });
            
            console.log('Active devices (non-Windows):', activeDevices.length);
            
            // Filter out personal devices
            const nonPersonalDevices = activeDevices.filter(device => {
                if (foundColumns.includes('deviceCategoryKey') && device.deviceCategoryKey) {
                    const category = device.deviceCategoryKey.toString().toLowerCase();
                    
                    if (category.includes('personal') && 
                        !category.includes('backstock') && 
                        !category.includes('back stock') &&
                        !category.includes('corporate') &&
                        !category.includes('company') &&
                        !category.includes('business')) {
                        return false;
                    }
                    
                    if (category.includes('backstock') || category.includes('back stock')) {
                        return true;
                    }
                }
                return true;
            });
            
            console.log('Non-personal devices:', nonPersonalDevices.length);
            
            // Get all unique categories from filtered data
            const allCategories = new Set();
            const androidDevices = [];
            const iosDevices = [];
            
            nonPersonalDevices.forEach(device => {
                if (device.deviceCategoryKey) {
                    allCategories.add(device.deviceCategoryKey.toString().trim());
                }
                
                // Use the same OS detection logic as main processing
                let osDetected = false;
                if (foundColumns.includes('osVersion') && device.osVersion) {
                    const osVersion = device.osVersion.toString().toLowerCase();
                    if (osVersion.includes('ios')) {
                        iosDevices.push(device);
                        osDetected = true;
                    } else if (osVersion.includes('android')) {
                        androidDevices.push(device);
                        osDetected = true;
                    }
                }
                
                if (!osDetected) {
                    const deviceStr = JSON.stringify(device).toLowerCase();
                    if (deviceStr.includes('ios') || deviceStr.includes('iphone') || deviceStr.includes('ipad')) {
                        iosDevices.push(device);
                    } else if (deviceStr.includes('android')) {
                        androidDevices.push(device);
                    }
                }
            });
            
            console.log(`\nDevice breakdown (filtered):`);
            console.log(`- Android devices: ${androidDevices.length}`);
            console.log(`- iOS devices: ${iosDevices.length}`);
            
            console.log(`\nTotal unique categories found: ${allCategories.size}`);
            console.log('\nAll detected categories:');
            [...allCategories].sort().forEach(cat => {
                console.log(`   • "${cat}"`);
            });
            
            // Android specific analysis
            if (androidDevices.length > 0) {
                console.log('\n=== ANDROID CATEGORY ANALYSIS ===');
                const androidCats = {};
                const androidSample = [];
                
                androidDevices.forEach((device, index) => {
                    const cat = device.deviceCategoryKey ? device.deviceCategoryKey.toString().trim() : '(no category)';
                    androidCats[cat] = (androidCats[cat] || 0) + 1;
                    
                    if (index < 10) {
                        androidSample.push({
                            index,
                            category: cat,
                            deviceName: device.deviceName || device.displayName || 'Unknown',
                            fullDevice: device
                        });
                    }
                });
                
                console.log('Android category counts:');
                Object.entries(androidCats).sort((a, b) => b[1] - a[1]).forEach(([cat, count]) => {
                    console.log(`   • "${cat}": ${count} devices`);
                });
                
                console.log('\nSample of first 10 Android devices:');
                androidSample.forEach(sample => {
                    console.log(`   ${sample.index}: "${sample.category}" - ${sample.deviceName}`);
                });
            }
            
            // Check for specific categories the user mentioned
            const targetCategories = ['backstock', 'epic welcome', 'epic-welcome', 'epicwelcome', 'zebra', 'scanner'];
            console.log('\n=== SEARCHING FOR SPECIFIC CATEGORIES ===');
            targetCategories.forEach(target => {
                const found = [...allCategories].filter(cat => 
                    cat.toLowerCase().includes(target.toLowerCase())
                );
                if (found.length > 0) {
                    console.log(`   Found "${target}": ${found.join(', ')}`);
                } else {
                    console.log(`   Not found: "${target}"`);
                }
            });
            
            console.log('=== END CATEGORY DEBUG REPORT ===');
            
            // Show alert with summary
            const summary = `Debug complete! Check console for details.\n\n` +
                          `Total devices (unfiltered): ${data.length}\n` +
                          `Active devices (non-Windows): ${activeDevices.length}\n` +
                          `Non-personal devices: ${nonPersonalDevices.length}\n` +
                          `Android devices (filtered): ${androidDevices.length}\n` +
                          `Unique categories: ${allCategories.size}\n` +
                          `Category column found: ${foundColumns.includes('deviceCategoryKey')}`;
            
            alert(summary);
        }
    </script>
</body>
</html> 